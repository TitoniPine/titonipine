<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis | Plum Blossom</title>
    <meta name="generator" content="VuePress 1.9.2">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="知识管理">
    <meta name="keywords" content="vuepress,theme,blog,vdoing">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.d4aaf2aa.css" as="style"><link rel="preload" href="/assets/js/app.452883b7.js" as="script"><link rel="preload" href="/assets/js/2.56fd5cb0.js" as="script"><link rel="preload" href="/assets/js/11.0c5a5f56.js" as="script"><link rel="prefetch" href="/assets/js/10.e34745fa.js"><link rel="prefetch" href="/assets/js/12.e37a3bae.js"><link rel="prefetch" href="/assets/js/13.dec75161.js"><link rel="prefetch" href="/assets/js/14.f78337c3.js"><link rel="prefetch" href="/assets/js/15.99acbeb8.js"><link rel="prefetch" href="/assets/js/16.b65d0402.js"><link rel="prefetch" href="/assets/js/17.4d622483.js"><link rel="prefetch" href="/assets/js/18.5d6d74a0.js"><link rel="prefetch" href="/assets/js/3.5ae67027.js"><link rel="prefetch" href="/assets/js/4.cb2134f5.js"><link rel="prefetch" href="/assets/js/5.807ea28e.js"><link rel="prefetch" href="/assets/js/6.0d59ddfa.js"><link rel="prefetch" href="/assets/js/7.7d78bfbd.js"><link rel="prefetch" href="/assets/js/8.a96fa62e.js"><link rel="prefetch" href="/assets/js/9.ba92e156.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d4aaf2aa.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://cdn.jsdelivr.net/gh/TitoniPine/Images@main/uPic/cat1.png" alt="Plum Blossom" class="logo"> <span class="site-name can-hide">Plum Blossom</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/52d5c3/" class="nav-link">基础</a></div><div class="nav-item"><a href="/pages/ce6c78/" class="nav-link">框架</a></div><div class="nav-item"><a href="/pages/db78e2/" class="nav-link">工具</a></div><div class="nav-item"><a href="/pages/5d571c/" class="nav-link">项目</a></div><div class="nav-item"><a href="/pages/9cc27d/" class="nav-link">☁️</a></div><div class="nav-item"><a href="/pages/1b12ed/" class="nav-link">书籍</a></div> <a href="https://github.com/titonipine" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/52d5c3/" class="nav-link">基础</a></div><div class="nav-item"><a href="/pages/ce6c78/" class="nav-link">框架</a></div><div class="nav-item"><a href="/pages/db78e2/" class="nav-link">工具</a></div><div class="nav-item"><a href="/pages/5d571c/" class="nav-link">项目</a></div><div class="nav-item"><a href="/pages/9cc27d/" class="nav-link">☁️</a></div><div class="nav-item"><a href="/pages/1b12ed/" class="nav-link">书籍</a></div> <a href="https://github.com/titonipine" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/5aa973/" class="sidebar-link">Spring</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>安全框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ce6c78/" class="sidebar-link">JWT</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Mybatis</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>SpringBoot</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>web</span> <!----></p> <!----></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>非关系型数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/9a6634/" aria-current="page" class="active sidebar-link">Redis</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/9a6634/#一、概述" class="sidebar-link">一、概述</a></li><li class="sidebar-sub-header level2"><a href="/pages/9a6634/#二、redis-常见的数据结构" class="sidebar-link">二、Redis 常见的数据结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#string" class="sidebar-link">string</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#list" class="sidebar-link">list</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#hash" class="sidebar-link">hash</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#set" class="sidebar-link">set</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#sorted-set" class="sidebar-link">sorted set</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#bitmap" class="sidebar-link">bitmap</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/9a6634/#三、spring-data-redis" class="sidebar-link">三、Spring Data Redis</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#_1-redistemplate" class="sidebar-link">1. RedisTemplate</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#_2-序列化" class="sidebar-link">2. 序列化</a></li><li class="sidebar-sub-header level4"><a href="/pages/9a6634/#_2-1-rediserializer" class="sidebar-link">2.1 Rediserializer</a></li><li class="sidebar-sub-header level5"><a href="/pages/9a6634/#_2-1-1-string-序列化方式" class="sidebar-link">2.1.1 String 序列化方式</a></li><li class="sidebar-sub-header level5"><a href="/pages/9a6634/#_2-1-2-json-序列化方式" class="sidebar-link">2.1.2 JSON 序列化方式</a></li><li class="sidebar-sub-header level4"><a href="/pages/9a6634/#_2-2-配置序列化的方式" class="sidebar-link">2.2 配置序列化的方式</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#_3-redisson" class="sidebar-link">3. Redisson</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/9a6634/#四、缓存" class="sidebar-link">四、缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#_4-1-缓存设置过期时间" class="sidebar-link">4.1 缓存设置过期时间</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#_4-2-如何判断数据是否过期" class="sidebar-link">4.2 如何判断数据是否过期</a></li><li class="sidebar-sub-header level4"><a href="/pages/9a6634/#_4-2-1-过期删除策略" class="sidebar-link">4.2.1 过期删除策略</a></li><li class="sidebar-sub-header level4"><a href="/pages/9a6634/#_4-2-2-lru和lfu" class="sidebar-link">4.2.2 LRU和LFU</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#_4-3-缓存穿透" class="sidebar-link">4.3 缓存穿透</a></li><li class="sidebar-sub-header level4"><a href="/pages/9a6634/#什么是缓存穿透" class="sidebar-link">什么是缓存穿透？</a></li><li class="sidebar-sub-header level4"><a href="/pages/9a6634/#有哪些解决办法" class="sidebar-link">有哪些解决办法？</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#_4-4-缓存雪崩" class="sidebar-link">4.4 缓存雪崩</a></li><li class="sidebar-sub-header level4"><a href="/pages/9a6634/#什么是缓存雪崩" class="sidebar-link">什么是缓存雪崩？</a></li><li class="sidebar-sub-header level4"><a href="/pages/9a6634/#有哪些解决办法-2" class="sidebar-link">有哪些解决办法？</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#_4-5-如何保证缓存和数据库数据的一致性" class="sidebar-link">4.5 如何保证缓存和数据库数据的一致性？</a></li><li class="sidebar-sub-header level4"><a href="/pages/9a6634/#为什么会发生缓存和数据库的数据不一致" class="sidebar-link">为什么会发生缓存和数据库的数据不一致</a></li><li class="sidebar-sub-header level5"><a href="/pages/9a6634/#当redis作为读写缓存时" class="sidebar-link">当redis作为读写缓存时</a></li><li class="sidebar-sub-header level5"><a href="/pages/9a6634/#当redis-作为只读缓存时" class="sidebar-link">当redis 作为只读缓存时</a></li><li class="sidebar-sub-header level4"><a href="/pages/9a6634/#如何解决数据不一致问题" class="sidebar-link">如何解决数据不一致问题？</a></li><li class="sidebar-sub-header level6"><a href="/pages/9a6634/#第一种方法-重试机制" class="sidebar-link">第一种方法：重试机制</a></li><li class="sidebar-sub-header level6"><a href="/pages/9a6634/#情况一-先删除缓存-再更新数据库" class="sidebar-link">情况一：先删除缓存，再更新数据库</a></li><li class="sidebar-sub-header level6"><a href="/pages/9a6634/#情况二-先更新数据库值-再删除缓存值" class="sidebar-link">情况二：先更新数据库值，再删除缓存值</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/9a6634/#五、redis-的持久化机制" class="sidebar-link">五、Redis 的持久化机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#快照-snapshotting-持久化-rdb" class="sidebar-link">快照（snapshotting）持久化（RDB）</a></li><li class="sidebar-sub-header level3"><a href="/pages/9a6634/#aof-append-only-file-持久化" class="sidebar-link">AOF（append-only file）持久化</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/9a6634/#六、redis-事务" class="sidebar-link">六、Redis 事务</a></li><li class="sidebar-sub-header level2"><a href="/pages/9a6634/#七、redis-做消息队列" class="sidebar-link">七、Redis 做消息队列</a></li></ul></li><li><a href="/pages/0a0365/" class="sidebar-link">Elasticsearch</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MQ</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c267a5/" class="sidebar-link">RabbitMQ</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-0c557b5e><div class="articleInfo" data-v-0c557b5e><ul class="breadcrumbs" data-v-0c557b5e><li data-v-0c557b5e><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-0c557b5e></a></li> <li data-v-0c557b5e><span data-v-0c557b5e>框架</span></li><li data-v-0c557b5e><span data-v-0c557b5e>SpringBoot</span></li><li data-v-0c557b5e><span data-v-0c557b5e>非关系型数据库</span></li></ul> <div class="info" data-v-0c557b5e><div title="作者" class="author iconfont icon-touxiang" data-v-0c557b5e><a href="https://github.com/titonipine" target="_blank" title="作者" class="beLink" data-v-0c557b5e>Plum Blossom</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>2022-04-10</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Redis<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="一、概述"><a href="#一、概述" class="header-anchor">#</a> 一、概述</h2> <p><strong>Redis 是一个高性能的 key-value 数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p> <p>另外，<strong>Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。</strong></p> <p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p> <div class="custom-block tip"><p class="custom-block-title">`Redis的特点`：</p> <ol><li><strong>Redis支持数据的持久化</strong>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li> <li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。(<strong>Redis支持多数据结构存储</strong>)</li> <li><strong>Redis支持数据的备份</strong>，即master-slave模式的数据备份。</li></ol></div> <h2 id="二、redis-常见的数据结构"><a href="#二、redis-常见的数据结构" class="header-anchor">#</a> 二、Redis 常见的数据结构</h2> <h3 id="string"><a href="#string" class="header-anchor">#</a> string</h3> <ol><li><strong>介绍</strong> ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</li> <li><strong>常用命令：</strong> <code>set,get,strlen,exists,decr,incr,setex</code> 等等。</li> <li><strong>应用场景：</strong> 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li></ol> <div class="custom-block note"><p class="custom-block-title">**设置过期时间**</p> <p><code>SETEX key seconds value</code> 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</p> <p><code>PSETEX key milliseconds value</code>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</p> <p>其他类型使用 <code>EXPIRE key seconds</code>为给定 key 设置过期时间。</p></div> <h3 id="list"><a href="#list" class="header-anchor">#</a> list</h3> <ol><li><strong>介绍</strong> ：<strong>list</strong> 即是 <strong>链表</strong>。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 <strong>LinkedList</strong>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li> <li><strong>常用命令:</strong> <code>rpush,lpop,lpush,rpop,lrange,llen</code> 等。</li> <li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li></ol> <h3 id="hash"><a href="#hash" class="header-anchor">#</a> hash</h3> <ol><li><strong>介绍</strong> ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，<strong>hash 是一个 string 类型的 field 和 value 的映射表</strong>，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li> <li><strong>常用命令：</strong> <code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> 等。</li> <li><strong>应用场景:</strong> 系统中对象数据的存储。</li></ol> <h3 id="set"><a href="#set" class="header-anchor">#</a> set</h3> <ol><li><strong>介绍 ：</strong> set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序不重复集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</li> <li><strong>常用命令：</strong> <code>sadd,spop,smembers,sismember,scard,sinterstore,sunion</code> 等。</li> <li><strong>应用场景:</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</li></ol> <h3 id="sorted-set"><a href="#sorted-set" class="header-anchor">#</a> sorted set</h3> <ol><li><strong>介绍：</strong> 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</li> <li><strong>常用命令：</strong> <code>zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。</li> <li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li></ol> <h3 id="bitmap"><a href="#bitmap" class="header-anchor">#</a> bitmap</h3> <ol><li><strong>介绍：</strong> bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。</li> <li><strong>常用命令：</strong> <code>setbit</code> 、<code>getbit</code> 、<code>bitcount</code>、<code>bitop</code></li> <li><strong>应用场景：</strong> 适合需要保存状态信息（比如是否签到、是否登录...）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li></ol> <h2 id="三、spring-data-redis"><a href="#三、spring-data-redis" class="header-anchor">#</a> 三、Spring Data Redis</h2> <p>对于下层，Spring Data Redis 提供了统一的操作模板（后文中，我们会看到是 RedisTemplate 类），封装了 Jedis、Lettuce 的 API 操作，访问 Redis 数据。所以，<strong>实际上，Spring Data Redis 内置真正访问的实际是 Jedis、Lettuce 等 API 操作</strong>。</p> <p>目前Spring Data Redis 暂时只支持 Jedis、Lettuce 的内部封装，而 Redisson 是由 <a href="https://github.com/redisson/redisson/tree/master/redisson-spring-data" target="_blank" rel="noopener noreferrer">redisson-spring-data<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来提供。</p> <h3 id="_1-redistemplate"><a href="#_1-redistemplate" class="header-anchor">#</a> 1. RedisTemplate</h3> <p><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/core/RedisTemplate.java" target="_blank" rel="noopener noreferrer"><code>org.springframework.data.redis.core.RedisTemplate</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，从类名上，我们就明明白白知道，提供 Redis 操作模板 API 。核心属性如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 1、序列化相关属性</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">private</span> <span class="token class-name">RedisSerializer</span> keySerializer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">private</span> <span class="token class-name">RedisSerializer</span> valueSerializer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">private</span> <span class="token class-name">RedisSerializer</span> hashKeySerializer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">private</span> <span class="token class-name">RedisSerializer</span> hashValueSerializer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stringSerializer <span class="token operator">=</span> <span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2、Lua 脚本执行器</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">private</span> <span class="token class-name">ScriptExecutor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> scriptExecutor<span class="token punctuation">;</span>

<span class="token comment">// 3、常见数据结构操作类</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">private</span> <span class="token class-name">ValueOperations</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> valueOps<span class="token punctuation">;</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">private</span> <span class="token class-name">ListOperations</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> listOps<span class="token punctuation">;</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">private</span> <span class="token class-name">SetOperations</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> setOps<span class="token punctuation">;</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">private</span> <span class="token class-name">ZSetOperations</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> zSetOps<span class="token punctuation">;</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">private</span> <span class="token class-name">GeoOperations</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> geoOps<span class="token punctuation">;</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">private</span> <span class="token class-name">HyperLogLogOperations</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hllOps<span class="token punctuation">;</span>
</code></pre></div><h3 id="_2-序列化"><a href="#_2-序列化" class="header-anchor">#</a> 2. 序列化</h3> <h4 id="_2-1-rediserializer"><a href="#_2-1-rediserializer" class="header-anchor">#</a> 2.1 Rediserializer</h4> <p><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/serializer/RedisSerializer.java" target="_blank" rel="noopener noreferrer"><code>org.springframework.data.redis.serializer.RedisSerializer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 接口，Redis 序列化接口，用于 Redis KEY 和 VALUE 的序列化。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">T</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SerializationException</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Nullable</span>
    <span class="token class-name">T</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SerializationException</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">java</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">java</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">java</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkSerializationRedisSerializer</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">GenericJackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>定义了对象 <T> 和二进制数组的转换</T></li></ul> <p><strong>RedisSerializer 的实现类</strong></p> <p><img src="https://cdn.jsdelivr.net/gh/TitoniPine/Images@main/uPic/20220409211022.png" alt="20220409211022"></p> <p>主要分成四类：</p> <ul><li><strong>JDK 序列化方式</strong></li> <li><strong>String 序列化方式</strong></li> <li><strong>JSON 序列化方式</strong></li> <li><strong>XML 序列化方式</strong></li></ul> <h5 id="_2-1-1-string-序列化方式"><a href="#_2-1-1-string-序列化方式" class="header-anchor">#</a> 2.1.1 String 序列化方式</h5> <ol><li><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/serializer/StringRedisSerializer.java" target="_blank" rel="noopener noreferrer"><code>org.springframework.data.redis.serializer.StringRedisSerializer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，字符串和二进制数组的<strong>直接</strong>转换。代码如下：</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringRedisSerializer</span> <span class="token keyword">implements</span> <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Charset</span> charset<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">StringRedisSerializer</span> US_ASCII<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">StringRedisSerializer</span> ISO_8859_1<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">StringRedisSerializer</span> UTF_8<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Charset</span> charset<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>charset<span class="token punctuation">,</span> <span class="token string">&quot;Charset must not be null!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>charset <span class="token operator">=</span> charset<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> bytes <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>charset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">String</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> string <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> string<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>charset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        US_ASCII <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>US_ASCII<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ISO_8859_1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>ISO_8859_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        UTF_8 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>绝大多数情况下，我们 KEY 和 VALUE 都会使用这种序列化方案</strong>。</p> <ol start="2"><li><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/serializer/GenericToStringSerializer.java" target="_blank" rel="noopener noreferrer"><code>org.springframework.data.redis.serializer.GenericToStringSerializer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，使用 Spring <code>ConversionService</code> 实现 <code>&lt;T&gt;</code> 对象和 String 的转换，从而 String 和二进制数组的转换。</li></ol> <h5 id="_2-1-2-json-序列化方式"><a href="#_2-1-2-json-序列化方式" class="header-anchor">#</a> 2.1.2 JSON 序列化方式</h5> <ol><li><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/serializer/GenericJackson2JsonRedisSerializer.java" target="_blank" rel="noopener noreferrer"><code>org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，使用 Jackson 实现 JSON 的序列化方式，并且从 Generic 单词可以看出，是支持所有类。</li> <li><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/serializer/GenericJackson2JsonRedisSerializer.java" target="_blank" rel="noopener noreferrer"><code>org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，使用 Jackson 实现 JSON 的序列化方式，并且显示指定 <code>&lt;T&gt;</code> 类型。</li> <li><a href="https://github.com/alibaba/fastjson/blob/master/src/main/java/com/alibaba/fastjson/support/spring/GenericFastJsonRedisSerializer.java" target="_blank" rel="noopener noreferrer"><code>com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，使用 FastJSON 实现 JSON 的序列化方式，和 GenericJackson2JsonRedisSerializer 一致。</li> <li><a href="https://github.com/alibaba/fastjson/blob/master/src/main/java/com/alibaba/fastjson/support/spring/FastJsonRedisSerializer.java" target="_blank" rel="noopener noreferrer"><code>com.alibaba.fastjson.support.spring.FastJsonRedisSerializer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，使用 FastJSON 实现 JSON 的序列化方式，和 Jackson2JsonRedisSerializer 一致。</li></ol> <h4 id="_2-2-配置序列化的方式"><a href="#_2-2-配置序列化的方式" class="header-anchor">#</a> 2.2 配置序列化的方式</h4> <ol><li>创建 RedisConfiguration 配置类</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfiguration</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建 RedisTemplate 对象</span>
        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置 RedisConnection 工厂。</span>
        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 使用 String 序列化方式，序列化 KEY 。</span>
        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 使用 JSON 序列化方式（库是 Jackson ），序列化 VALUE 。</span>
        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> template<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><ul><li><p><code>RedisSerializer#string()</code> 静态方法，返回的就是使用 UTF-8 编码的 StringRedisSerializer 对象。代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// RedisSerializer.java</span>
<span class="token keyword">static</span> <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// StringRedisSerializer.java</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">StringRedisSerializer</span> ISO_8859_1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>ISO_8859_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>RedisSerializer#json()</code> 静态方法，返回 GenericJackson2JsonRedisSerializer 对象。代码如下：</p></li> <li><div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// RedisSerializer.java</span>

<span class="token keyword">static</span> <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">GenericJackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_3-redisson"><a href="#_3-redisson" class="header-anchor">#</a> 3. Redisson</h3> <p>Redisson在基于NIO的<a href="http://netty.io/" target="_blank" rel="noopener noreferrer">Netty<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>框架上，充分的利用了Redis键值数据库提供的一系列优势，在Java实用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。</p> <h2 id="四、缓存"><a href="#四、缓存" class="header-anchor">#</a> 四、缓存</h2> <h3 id="_4-1-缓存设置过期时间"><a href="#_4-1-缓存设置过期时间" class="header-anchor">#</a> 4.1 缓存设置过期时间</h3> <p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p> <p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p> <p><strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p> <p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p> <p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p> <p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p> <h3 id="_4-2-如何判断数据是否过期"><a href="#_4-2-如何判断数据是否过期" class="header-anchor">#</a> 4.2 如何判断数据是否过期</h3> <p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p> <h4 id="_4-2-1-过期删除策略"><a href="#_4-2-1-过期删除策略" class="header-anchor">#</a> 4.2.1 过期删除策略</h4> <p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p> <p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p> <ol><li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li> <li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol> <p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p> <p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p> <p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p> <ul><li><p>设置淘汰策略</p> <div class="language-shell extra-class"><pre class="language-shell"><code>config <span class="token builtin class-name">set</span> maxmemory-policy allkeys-lru
</code></pre></div></li></ul> <p>Redis 提供 6 种数据淘汰策略：</p> <ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li> <li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li> <li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li> <li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li> <li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li> <li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol> <p>4.0 版本后增加以下两种：</p> <ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li> <li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol> <h4 id="_4-2-2-lru和lfu"><a href="#_4-2-2-lru和lfu" class="header-anchor">#</a> 4.2.2 LRU和LFU</h4> <ul><li><p>LRU（Least Recently Used）</p> <p>即<code>最近最少使用</code>，会将最不常用的数据筛选出来，保留最近频繁使用的数据。LRU 会把所有数据组成一个链表，链表头部称为 MRU，代表最近最常使用的数据；尾部称为 LRU代表最近最不常使用的数据；</p> <p><strong>但是，如果直接在 Redis 中使用 LRU 算法也会有一些问题：</strong></p> <p>LRU 算法在实现过程中使用链表管理所有缓存的数据，这会给 Redis 带来额外的开销，而且，当有数据访问时就会有链表移动操作，进而降低 Redis 的性能。</p> <p>于是，Redis 对 LRU 的实现进行了一些改变：</p> <ul><li>记录每个 key 最近一次被访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）</li> <li>在第一次淘汰数据时，会先随机选择 N 个数据作为一个候选集合，然后淘汰 lru 值最小的。（N 可以通过 config set maxmemory-samples 100 命令来配置）</li> <li>后续再淘汰数据时，会挑选数据进入候选集合，进入集合的条件是：它的 lru 小于候选集合中最小的 lru。</li> <li>如果候选集合中数据个数达到了 maxmemory-samples，Redis 就会将 lru 值小的数据淘汰出去。</li></ul></li> <li><p>LFU（Least Frequently Used）</p> <p>即最不经常使用策略，它是基于数据访问次数来淘汰数据的，在 Redis 4.0 时添加进来。它在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。</p> <p>前面说到，LRU 使用了 RedisObject 中的 lru 字段记录时间戳，lru 是 24bit 的，LFU 将 lru 拆分为两部分：</p> <ul><li>ldt 值：lru 字段的前 16bit，表示数据的访问时间戳</li> <li>counter 值：lru 字段的后 8bit，表示数据的访问次数 使用 LFU 策略淘汰缓存时，会把访问次数最低的数据淘汰，如果访问次数相同，再根据访问的时间，将访问时间戳最小的淘汰。</li></ul> <p><strong>为什么 Redis 有了 LRU 还需要 LFU 呢？</strong></p> <p>在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白占用缓存空间。</p> <p>由于 LRU 是基于访问时间的，如果系统对大量数据进行单次查询，这些数据的 lru 值就很大，使用 LFU 算法就不容易被淘汰。</p></li></ul> <h3 id="_4-3-缓存穿透"><a href="#_4-3-缓存穿透" class="header-anchor">#</a> 4.3 缓存穿透</h3> <h4 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="header-anchor">#</a> 什么是缓存穿透？</h4> <p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p> <h4 id="有哪些解决办法"><a href="#有哪些解决办法" class="header-anchor">#</a> 有哪些解决办法？</h4> <p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p> <p><strong>1）缓存无效 key</strong></p> <p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p> <p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p> <p><strong>2）布隆过滤器</strong></p> <p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p> <p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p> <p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p> <p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p> <p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p> <ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li> <li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol> <p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p> <ol><li>对给定元素再次进行相同的哈希计算；</li> <li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol> <p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p> <h3 id="_4-4-缓存雪崩"><a href="#_4-4-缓存雪崩" class="header-anchor">#</a> 4.4 缓存雪崩</h3> <h4 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="header-anchor">#</a> 什么是缓存雪崩？</h4> <p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p> <p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p> <p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p> <p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p> <h4 id="有哪些解决办法-2"><a href="#有哪些解决办法-2" class="header-anchor">#</a> 有哪些解决办法？</h4> <p><strong>针对 Redis 服务不可用的情况：</strong></p> <ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li> <li>限流，避免同时处理大量的请求。</li></ol> <p><strong>针对热点缓存失效的情况：</strong></p> <ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li> <li>缓存永不失效。</li></ol> <h3 id="_4-5-如何保证缓存和数据库数据的一致性"><a href="#_4-5-如何保证缓存和数据库数据的一致性" class="header-anchor">#</a> 4.5 如何保证缓存和数据库数据的一致性？</h3> <p>首先，我们必须知道这里的“数据一致性”是什么意思。这里“一致性”包括两种情况：</p> <ul><li>缓存中有数据，那么，缓存的数据需要和数据库中的值相同</li> <li>缓存中本身没有数据，那么，数据库中的值就必须是最新值。</li></ul> <p>不符合这两种情况的，就是缓存和数据库的数据不一致了。</p> <h4 id="为什么会发生缓存和数据库的数据不一致"><a href="#为什么会发生缓存和数据库的数据不一致" class="header-anchor">#</a> 为什么会发生缓存和数据库的数据不一致</h4> <p>当缓存的读写模式不同时，缓存数据不一致发生的情况不一样。</p> <h5 id="当redis作为读写缓存时"><a href="#当redis作为读写缓存时" class="header-anchor">#</a> 当redis作为读写缓存时</h5> <p>对于读写缓存来说，如果要对数据进行增删改，就需要在缓存中进行，同时还要根据采取的写回策略，决定是否同步写回到数据库中。</p> <ul><li><code>同步直写策略</code>：写缓存时，也同步写数据库，缓存和数据库中的数据一致</li> <li><code>异步写回策略</code>：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障。那么，此时，数据库就没有最新数据了</li></ul> <p>所以，对于读写缓存来说，要想保证缓存和数据库中的数据一致，就要采用同步直写策略。不过，需要注意的是：如果采用这种策略，<strong>就需要保证同时更新缓存和数据库</strong>。所以，我们<strong>要在业务应用中使用事务机制</strong>，来保证缓存和数据库的更新具有原子性，也就是说，两者要不一起更新，要不都不更新，返回错误信息，进行重试。否则，我们就无法实现同步直接</p> <p>当然，在有些场景下，我们对数据一致性的要求可能不是那么高，那么，我们可以使用异步写回策略。</p> <h5 id="当redis-作为只读缓存时"><a href="#当redis-作为只读缓存时" class="header-anchor">#</a> 当redis 作为只读缓存时</h5> <p>对于只读缓存来说：</p> <ul><li>如果有数据新增，会直接写入数据库；</li> <li>有数据删改时，就需要把只读缓存中的数据标记为无效
<ul><li>这样，应用后继在访问这些，些增删改的数据时，因为缓存中没有相应的数据，就会发生缓存缺失。</li> <li>此时，应用再从数据库中把数据读入缓存，这样后续再访问数据时，就能够直接从缓存中读取了。</li></ul></li></ul> <p>那么，这个过程中会不会出现数据不一致的情况呢？
（1）新增数据：</p> <ul><li>如果是新增数据，数据会直接写到数据库中，不用对缓存做任何操作。此时，缓存中本身就没有新增数据，而数据库中是最新值</li> <li>这种情况符合我们刚刚所说的一致性的第 2 种情况，所以，此时，缓存和数据库的数据是一致的。</li></ul> <p>（2）删改数据</p> <p>如果发生删改操作，应用既要更新数据库，也要在缓存中删除数据。这两个操作如果无法保证原子性，也就是说，要不都完成，要不都没完成，此时，就会出现数据不一致问题了。</p> <ul><li>我们假设应用先删除缓存，再更新数据库，如果缓存删除成功，但是数据库更新失败，那么，应用再访问数据时，缓存中没有数据，就会发生缓存缺失。然后，应用再访问数据库，但是数据库中的值为旧值，应用就访问到旧值了。</li> <li>如果应用先完成了数据库的更新，但是，在删除缓存时失败了，那么，数据库中的值是新值，而缓存中的是旧值，这肯定是不一致的。这个时候，如果有其他的并发请求来访问数据，按照正常的缓存访问流程，就会先在缓存中查询，但此时，就会读到旧值了。</li></ul> <p>总结：<strong>在更新数据库和删除缓存值的过程中，无论这两个操作的执行顺序谁先谁后，只要有一个操作失败了，就会导致客户端读取到旧值</strong></p> <h4 id="如何解决数据不一致问题"><a href="#如何解决数据不一致问题" class="header-anchor">#</a> 如何解决数据不一致问题？</h4> <h6 id="第一种方法-重试机制"><a href="#第一种方法-重试机制" class="header-anchor">#</a> 第一种方法：重试机制</h6> <p>具体的说，就是：</p> <ul><li>可以把要删除的缓存值或者要更新的数据库值暂存到消息队列中。当应用没有能够成功的删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或者更新</li> <li>如果能够成功删除或者更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存一致了。否则的话，我们还需要再次进行重试。如果重试超过一定次数，还是没有成功，我们就需要向应用层发送报错信息了。</li></ul> <p>刚刚说的是在更新数据库和删除缓存值的过程中，其中一个操作失败的情况，实际上，即使这两个操作第一次执行时都没有失败，当有大量并发请求时，应用还是有可能读到不一致的数据</p> <p>同样，我们按照不同的删除和更新顺序，分成两种情况来看。在这两种情况下，我们的解决方法也有所不同。</p> <h6 id="情况一-先删除缓存-再更新数据库"><a href="#情况一-先删除缓存-再更新数据库" class="header-anchor">#</a> 情况一：先删除缓存，再更新数据库</h6> <p>假设线程 A 删除缓存值后，还没有来得及更新数据库（比如说有网络延迟），线程 B 就开始读取数据了，那么这个时候，线程 B 会发现缓存缺失，就只能去数据库读取。这会带来两个问题：</p> <ol><li>线程 B 读取到了旧值；</li> <li>线程 B 是在缓存缺失的情况下读取的数据库，所以，它还会把旧值写入缓存，这可能会导致其他线程从缓存中读到旧值。</li></ol> <p>怎么解决呢？<strong>在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。</strong></p> <ul><li>之所以要加上 sleep 的这段时间，就是为了让线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程 A 再进行删除。所以，线程 A sleep 的时间，就需要大于线
程 B 读取数据再写入缓存的时间。这个时间怎么确定呢？建议你在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算。</li> <li>这样一来，其它线程读取数据时，会发现缓存缺失，所以会从数据库中读取最新值。因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫做“延迟双删”。</li></ul> <h6 id="情况二-先更新数据库值-再删除缓存值"><a href="#情况二-先更新数据库值-再删除缓存值" class="header-anchor">#</a> 情况二：先更新数据库值，再删除缓存值</h6> <ul><li>如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。</li> <li>不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程 A 一般也会很快删除缓存值，这样一来，其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小。</li></ul> <p>方法也是延迟双删。</p> <h2 id="五、redis-的持久化机制"><a href="#五、redis-的持久化机制" class="header-anchor">#</a> 五、Redis 的持久化机制</h2> <p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p> <p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p> <h3 id="快照-snapshotting-持久化-rdb"><a href="#快照-snapshotting-持久化-rdb" class="header-anchor">#</a> <strong>快照（snapshotting）持久化（RDB）</strong></h3> <p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p> <p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p> <blockquote><p>save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</p> <p>save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</p> <p>save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</p></blockquote> <h3 id="aof-append-only-file-持久化"><a href="#aof-append-only-file-持久化" class="header-anchor">#</a> <strong>AOF（append-only file）持久化</strong></h3> <p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p> <blockquote><p>appendonly yes</p></blockquote> <p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p> <p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p> <p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p> <blockquote><p>appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步</p></blockquote> <p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p> <h2 id="六、redis-事务"><a href="#六、redis-事务" class="header-anchor">#</a> 六、Redis 事务</h2> <p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p> <p>使用 <a href="https://redis.io/commands/multi" target="_blank" rel="noopener noreferrer"><code>MULTI</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href="https://redis.io/commands/exec" target="_blank" rel="noopener noreferrer"><code>EXEC</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 命令将执行所有命令。</p> <p>这个过程是这样的：</p> <ol><li>开始事务（<code>MULTI</code>）。</li> <li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li> <li>执行事务(<code>EXEC</code>)。</li></ol> <p>你也可以通过 <a href="https://redis.io/commands/discard" target="_blank" rel="noopener noreferrer"><code>DISCARD</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p> <p><a href="https://redis.io/commands/watch" target="_blank" rel="noopener noreferrer"><code>WATCH</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p> <p><strong>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</strong></p> <p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p> <p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p> <h2 id="七、redis-做消息队列"><a href="#七、redis-做消息队列" class="header-anchor">#</a> 七、Redis 做消息队列</h2> <p>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：</p> <ul><li>发布 / 订阅模式</li> <li>按照消费者组进行消费</li> <li>消息持久化（ RDB 和 AOF）</li></ul> <p>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p> <p>我们通常建议是不需要使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p></div></div> <div class="page-slot page-slot-bottom">
  <div class="wwads-cn wwads-horizontal pageB" data-id="136" style="width:100%;max-height:80px;min-height:auto;"></div>
  <style>
    .pageB img{width:80px!important;}
    .wwads-horizontal .wwads-text, .wwads-content .wwads-text{line-height:1;}
  </style>
  </div> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/04/13, 17:22:27</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/ce6c78/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">JWT</div></a> <a href="/pages/0a0365/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Elasticsearch</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/ce6c78/" class="prev">JWT</a></span> <span class="next"><a href="/pages/0a0365/">Elasticsearch</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:hyt10101025@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/titonipine" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2022
    <span>Plum Blossom | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><span class="close-but">×</span> <div>
    <div class="wwads-cn wwads-vertical windowRB" data-id="136" style="max-width:160px;
    min-width: auto;min-height:auto;"></div>
    <style>
      .windowRB{ padding: 0;}
      .windowRB .wwads-img{margin-top: 10px;}
      .windowRB .wwads-content{margin: 0 10px 10px 10px;}
      .custom-html-window-rb .close-but{
        display: none;
      }
    </style>
  </div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.452883b7.js" defer></script><script src="/assets/js/2.56fd5cb0.js" defer></script><script src="/assets/js/11.0c5a5f56.js" defer></script>
  </body>
</html>
