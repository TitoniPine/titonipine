---
title: Spring
date: 2022-04-10 11:43:55
permalink: /pages/5aa973/
---


## 一、概述

Spring是一个`轻量级的Java开发框架`，目的是为了解决企业级应用开发的业务逻辑和其他各层的耦合问题。

Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是**依赖注入（dependency injection，DI）** 和 **面向切面编程（aspect-oriented programming，AOP）**。

### 1.1 设计理念和核心

**Spring设计理念**：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；

**Spring框架的核心**：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。

### 1.2 优缺点

- 优点：
  1. 方便解耦，简化开发
  2. AOP编程的支持
  3. 声明式事务的支持
  4. 方便程序的测试
  5. 方便集成各种优秀框架
  6. 降低JavaEE API的使用难度

- 缺点：
  1. Spring依赖反射，反射影响性能

## 二、结构

### 2.1 组成模块

Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在`核心容器（Core Container）` 、`AOP（Aspect Oriented Programming）`和`设备支持（Instrmentation）` 、`数据访问与集成（Data Access/Integeration）` 、 `Web`、 `消息（Messaging）` 、 `Test`等 6 个模块中。 以下是 Spring 5 的模块结构图：

![Spring模块结构图](https://cdn.jsdelivr.net/gh/TitoniPine/Images@main/uPic/20220330185614.png)

- spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。
- spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。
- spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。
- spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。
- spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。
- spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。
- spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。

### 2.2 用到的设计模式

1. 工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；
2. 单例模式：Bean默认为单例模式。
3. 代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；
4. 模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。
5. 观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。

## 三、IOC

Inversion of Control 它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。

Spring IOC 负责创建对象，管理对象（通过依赖注入（DI）），装配对象，配置对象，并且管理这些对象的整个生命周期。

### 3.1 bean对象的注册

#### 3.1.1 @Configuration 和 @Bean 的批量注册

`@Configuration`加在类上，让这个类的功能等同于一个 bean.xml 配置文件。

:::warning
被 @Configuration 修饰的类，spring容器中会通过cglib给这个类创建一个代理，代理会拦截所有被 @Bean 修饰的方法，默认情况（bean为单例）下确保这些方法只被调用一次，从而确保这些bean是同一个bean，即单例的。
:::

`@Bean`用到方法上，类似于 bean.xml 配置文件中的 bean 元素，用来在 spring 容器中注册一个 bean。

#### 3.1.2 @ComponentScan 扫描包

`@ComponentScan`这个注解会让spring去扫描某些包及其子包中所有的类，然后将满足一定条件的类作为bean注册到spring容器容器中。
:::tip
所以玩这个注解，主要关注2个问题：

第一个：需要扫描哪些包？通过value、backPackages、basePackageClasses这3个参数来控制

第二：过滤器有哪些？通过useDefaultFilters、includeFilters、excludeFilters这3个参数来控制过滤器

这两个问题搞清楚了，就可以确定哪些类会被注册到容器中。

默认情况下，任何参数都不设置的情况下，此时，会将@ComponentScan修饰的类所在的包作为扫描包；默认情况下useDefaultFilters为true，这个为true的时候，spring容器内部会使用默认过滤器，规则是：凡是类上有@Repository、@Service、@Controller、@Component这几个注解中的任何一个的，那么这个类就会被作为bean注册到spring容器中，所以默认情况下，只需在类上加上这几个注解中的任何一个，这些类就会自动交给spring容器来管理了。
:::

#### 3.1.3 @Import

`@Import`可以用来批量导入需要注册的各种类，如普通的类、配置类，完后完成普通类和配置类中所有bean的注册。
:::warning
@Import的value常见的有5种用法

1. value为普通的类
2. value为@Configuration标注的类
3. value为@CompontentScan标注的类
4. value为ImportBeanDefinitionRegistrar接口类型
5. value为ImportSelector接口类型
6. value为DeferredImportSelector接口类型
   :::

### 3.2 注解实现依赖注入

#### 3.2.1 @Autowired

实现依赖注入，spring容器会对bean中所有`字段、方法`进行遍历，标注有@Autowired注解的，都会进行注入。

多个参数的时候，方法上面的@Autowire默认对方法中所有参数起效，如果我们想对某个参数进行特定的配置，**可以在参数上加上@Autowired(required = false)**，这个配置会覆盖方法上面的@Autowired配置。

**required为false：表示这个bean不是强制注入的，能找到就注入，找不到就注入一个null对象**


:::warning
@Autowired 查找候选者的过程

按类型找->通过限定符@Qualifier过滤->@Primary->@Priority->根据名称找（字段名称或者方法名称）
:::

#### 3.2.2 @Resource

和@Autowired注解类似，也是用来注入依赖的对象的，spring容器会对bean中所有字段、方法进行遍历，标注有@Resource注解的，都会进行注入。

:::warning
@Resource 查找候选者的过程

先按Resource的name值作为bean名称找->按名称（字段名称、方法名称、set属性名称）找->按类型找->通过限定符@Qualifier过滤->@Primary->@Priority->根据名称找（字段名称或者方法参数名称）
:::

#### 3.2.3 其他注解

- @Qualifier：可以在依赖注入查找候选者的过程中对候选者进行过滤。用在类、字段、方法和方法参数上
- @Primary：设置为主要候选者

### 3.3 其他注解的作用

#### 3.3.1 @Scope

指定bean的作用域。

用法：

1. 和@Compontent一起使用在类上
2. 和@Bean一起标注在方法上

#### 3.3.2 @DependsOn

指定当前bean依赖的bean，@DependsOn可以指定当前bean依赖的bean，通过这个可以确保@DependsOn指定的bean在当前bean创建之前先创建好

用法：

1. 和@Compontent一起使用在类上
2. 和@Bean一起标注在方法上

#### 3.3.3 @ImportSource

配置类中导入bean定义的配置文件，有些项目，前期可能采用xml的方式配置bean，后期可能想采用spring注解的方式来重构项目，但是有些老的模块可能还是xml的方式，spring为了方便在注解方式中兼容老的xml的方式，提供了@ImportResource注解来引入bean定义的配置文件。

#### 3.3.4 @Lazy

延迟初始化，@Lazy等效于bean xml中bean元素的lazy-init属性，可以实现bean的延迟初始化。

用法：

1. 和@Compontent一起标注在类上，可以是这个类延迟初始化
2. 和@Configuration一起标注在配置类中，可以让当前配置类中通过@Bean注册的bean延迟初始化
3. 和@Bean一起使用，可以使当前bean延迟初始化

#### 3.3.5 @Value

@Value可以标注在字段上面，可以引入外部配置文件中的数据，比如可以将数据库的一些配置信息放在配置文件中，然后通过@Value的方式将其注入到bean的一些字段中


### 3.4 bean的生命周期

1. **将各种方式定义的bean的信息，解析成BeanDefinition对象,注册到spring容器中**。

      :::warning
      BeanDefinition里面里面包含了bean定义的各种信息，如：bean对应的class、scope、lazy信息、dependOn信息、autowireCandidate（是否是候选对象）、primary（是否是主要的候选者）等信息。
      :::

2. bean 的注册

   bean注册阶段需要用到一个非常重要的接口：`BeanDefinitionRegistry`

   BeanDefinitionRegistry唯一实现：`DefaultListableBeanFactory`

3. **BeanDefinition合并阶段**

   可能我们定义bean的时候有父子bean关系，此时子BeanDefinition中的信息是不完整的，比如设置属性的时候配置在父BeanDefinition中，此时子BeanDefinition中是没有这些信息的，需要将子bean的BeanDefinition和父bean的BeanDefinition进行合并，得到最终的一个RootBeanDefinition，合并之后得到的RootBeanDefinition包含bean定义的所有信息，包含了从父bean中继继承过来的所有信息，后续bean的所有创建工作就是依靠合并之后BeanDefinition来进行的。

4. **Bean Class加载阶段**
   这个阶段就是将bean的class名称转换为Class类型的对象。此时会对阶段3中合并产生的`RootBeanDefinition`中的`beanClass`进行解析，将bean的类名转换为`Class对象`，然后赋值给`beanClass`字段。

5. **通过反射调用bean的构造器，实例化bean**

   `Bean实例化前操作`

   先来看一下`DefaultListableBeanFactory`，这个类中有个非常非常重要的字段：

   ```java
   private final List<BeanPostProcessor> beanPostProcessors = new CopyOnWriteArrayList<>();
   ```

   是一个`BeanPostProcessor`类型的集合

   **BeanPostProcessor是一个接口，还有很多子接口，这些接口中提供了很多方法，spring在bean生命周期的不同阶段，会调用上面这个列表中的BeanPostProcessor中的一些方法，来对生命周期进行扩展，bean生命周期中的所有扩展点都是依靠这个集合中的BeanPostProcessor来实现的，所以如果大家想对bean的生命周期进行干预，这块一定要掌握好。**

   **注意：本文中很多以BeanPostProcessor结尾的，都实现了BeanPostProcessor接口，有些是直接实现的，有些是实现了它的子接口。**

   Bean实例化之前会调用一段代码：

   ```java 
   @Nullable
       protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {
           for (BeanPostProcessor bp : getBeanPostProcessors()) {
               if (bp instanceof InstantiationAwareBeanPostProcessor) {
                   InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                   Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
                   if (result != null) {
                       return result;
                   }
               }
           }
           return null;
       }
   ```

   这段代码在bean实例化之前给开发者留了个口子，开发者自己可以在这个地方直接去创建一个对象作为bean实例，而跳过spring内部实例化bean的过程。

   上面代码中轮询`beanPostProcessors`列表，如果类型是`InstantiationAwareBeanPostProcessor`， 尝试调用`InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation`获取bean的实例对象，如果能够获取到，那么将返回值作为当前bean的实例，那么spring自带的实例化bean的过程就被跳过了。

   `postProcessBeforeInstantiation`方法如下：

   ```java 
   default Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {
       return null;
   }
   ```

   > 这个地方给开发者提供了一个扩展点，允许开发者在这个方法中直接返回bean的一个实例。

   实际上，在实例化前阶段对bean的创建进行干预的情况，用的非常少，所以大部分bean的创建还会继续走下面的阶段。

   `Bean实例化操作`

    **这个过程可以干什么？**

   这个过程会通过反射来调用bean的构造器来创建bean的实例。

   具体需要使用哪个构造器，spring为开发者提供了一个接口，允许开发者自己来判断用哪个构造器。

   看一下这块的代码逻辑：

   ```java 
   for (BeanPostProcessor bp : getBeanPostProcessors()) {
       if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
           SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
           Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
           if (ctors != null) {
               return ctors;
           }
       }
   }
   ```

   会调用`SmartInstantiationAwareBeanPostProcessor接口的determineCandidateConstructors`方法，这个方法会返回候选的构造器列表，也可以返回空，看一下这个方法的源码：

   ```java
   @Nullable
   default Constructor<?>[] determineCandidateConstructors(Class<?> beanClass, String beanName)
   throws BeansException {
   
       return null;
   }
   ```

   这个方法有个比较重要的实现类

   ```java
   org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
   ```

   可以将`@Autowired`标注的方法作为候选构造器返回。

6. **bean的属性填充**
   :::warning
   Bean 属性赋值前会调用`InstantiationAwareBeanPostProcessor`接口的`postProcessProperties`方法

   Bean 属性赋值阶段，这个过程比较简单了，循环处理PropertyValues中的属性值信息，**通过反射调用set方法将属性的值设置到bean实例中。**
   :::

7. **bean的初始化阶段**

   - Bean Aware 接口回调

     ```java 
     private void invokeAwareMethods(final String beanName, final Object bean) {
             if (bean instanceof Aware) {
                 if (bean instanceof BeanNameAware) {
                     ((BeanNameAware) bean).setBeanName(beanName);
                 }
                 if (bean instanceof BeanClassLoaderAware) {
                     ClassLoader bcl = getBeanClassLoader();
                     if (bcl != null) {
                         ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
                     }
                 }
                 if (bean instanceof BeanFactoryAware) {
                     ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
                 }
             }
         }
     ```

     如果我们的bean实例实现了上面的接口，会按照下面的顺序依次进行调用：

     ```
     BeanNameAware：将bean的名称注入进去
     BeanClassLoaderAware：将BeanClassLoader注入进去
     BeanFactoryAware：将BeanFactory注入进去
     ```

   - 初始化前

     会调用BeanPostProcessor的postProcessBeforeInitialization方法，若返回null，当前方法将结束。

   - 初始化阶段

      2个步骤

     1. 调用InitializingBean接口的afterPropertiesSet方法
     2. 调用定义bean的时候指定的初始化方法（@Bean(initMethod = "初始化的方法")）。

   - 初始化后

     调用BeanPostProcessor接口的postProcessAfterInitialization方法，返回null的时候，会中断上面的操作。

8. **bean的使用阶段**

9. **bean的销毁阶段**

   :::note

   3. 触发bean销毁的几种方式:

   1. 调用org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#destroyBean
   2. 调用org.springframework.beans.factory.config.ConfigurableBeanFactory#destroySingletons
   3. 调用ApplicationContext中的close方法

   Bean销毁阶段会依次执行

   1. 轮询beanPostProcessors列表，如果是DestructionAwareBeanPostProcessor这种类型的，会调用其内部的postProcessBeforeDestruction方法
   2. 如果bean实现了org.springframework.beans.factory.DisposableBean接口，会调用这个接口中的destroy方法
   3. 调用bean自定义的销毁方法(@Bean(destroyMethod = "销毁的方法"))

   :::

### 3.5 Bean循环依赖

多个bean之间相互依赖，形成了一个闭环。

检测循环依赖：检测循环依赖比较简单，使用一个列表来记录正在创建中的bean，bean创建之前，先去记录中看一下自己是否已经在列表中了，如果在，说明存在循环依赖，如果不在，则将其加入到这个列表，bean创建完毕之后，将其再从这个列表中移除。

解决循环依赖：

- 构造器的循环依赖无法解决
- 只有单例的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。

## 四、AOP

面向切面编程，spring中提供的一些非常牛逼的功能都是通过aop实现的，比如下面这些大家比较熟悉的功能

spring事务管理：@Transactional

spring异步处理：@EnableAsync

spring缓存技术的使用：@EnableCaching

spring中各种拦截器：@EnableAspectJAutoProxy

### 4.1 代理

#### 4.1.1 静态代理

#### 4.1.2 动态代理

- JDK 动态代理

  jdk中为实现代理提供了支持，主要用到2个类：

  ```
  java.lang.reflect.Proxy
  java.lang.reflect.InvocationHandler
  ```

  - proxy

    里面的一些重要的静态方法

    ```java
    //为指定的接口创建代理类，返回代理类的Class对象
    public static Class<?> getProxyClass(ClassLoader loader,Class<?>... interfaces)
    //创建代理类的实例对象
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
    //判断指定的类是否是一个代理类
    public static boolean isProxyClass(Class<?> cl)
    //获取代理对象的InvocationHandler对象
    public static InvocationHandler getInvocationHandler(Object proxy)
        throws IllegalArgumentException
    ```

    `创建方式一`:
    :::note

    1. 调用Proxy.getProxyClass方法获取代理类的Class对象
    2. 使用InvocationHandler接口创建代理类的处理器
    3. 通过代理类和InvocationHandler创建代理对象
    4. 上面已经创建好代理对象了，接着我们就可以使用代理对象了
       :::
       `创建方式二`:
       :::note
    5. 使用InvocationHandler接口创建代理类的处理器
    6. 使用Proxy类的静态方法newProxyInstance直接创建代理对象
    7. 使用代理对象
       :::

:::warning
JDK动态代理**只能为接口或接口的实现类创建代理类**，不能直接给普通类创建代理类。

JDK动态代理是编译时增强。
:::

- CGLIB 动态代理

jdk动态代理只能为接口创建代理，使用上有局限性。实际的场景中我们的类不一定有接口，此时如果我们想为普通的类也实现代理功能，我们就需要用到cglib来实现了。

cglib是一个强大、高性能的字节码生成库，它用于在运行时扩展Java类和实现接口；本质上它是通过动态的生成一个子类去覆盖所要代理的类（非final修饰的类和方法）。Enhancer可能是CGLIB中最常用的一个类，和jdk中的Proxy不同的是，Enhancer既能够代理普通的class，也能够代理接口。

`创建方式`：
:::note

1. 定义一个类；
2. 自定义 MethodInterceptor 并重写 intercept 方法，intercept用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；
3. 通过 Enhancer 类的 create()创建代理类；

:::

特点：

1. cglib弥补了jdk动态代理的不足，jdk动态代理只能为接口创建代理，而cglib非常强大，不管是接口还是类，都可以使用cglib来创建代理
2. cglib创建代理的过程，**相当于创建了一个新的类，可以通过cglib来配置这个新的类需要实现的接口，以及需要继承的父类**
3. cglib可以为类创建代理，但是**这个类不能是final类型的**，cglib为类创建代理的过程，**实际上为通过继承来实现的，相当于给需要被代理的类创建了一个子类，然后会重写父类中的方法，来进行增强**，继承的特性大家应该都知道，final修饰的类是不能被继承的，final修饰的方法不能被重写，static修饰的方法也不能被重写，private修饰的方法也不能被子类重写，而其他类型的方法都可以被子类重写，被重写的这些方法可以通过cglib进行拦截增强

### 4.2 AOP的一些概念

- 目标对象(target)

  目标对象指将要被增强的对象，即包含主业务逻辑的类对象。

- 连接点(JoinPoint)

  程序执行过程中明确的点，如方法的调用或特定的异常被抛出。

  连接点由两个信息确定：

  方法(表示程序执行点，即在哪个目标方法)

  相对点(表示方位，即目标方法的什么位置，比如调用前，后等)

  简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。

- 代理对象(Proxy)

  AOP中会通过代理的方式，对目标对象生成一个代理对象，代理对象中会加入需要增强功能，通过代理对象来间接的方式目标对象，起到增强目标对象的效果。

- 通知(Advice)

  需要在目标对象中增强的功能，如上面说的：业务方法前验证用户的功能、方法执行之后打印方法的执行日志。

  通知中有2个重要的信息：方法的什么地方，执行什么操作，这2个信息通过通知来指定。

  方法的什么地方？之前、之后、包裹目标方法、方法抛出异常后等。

  如：

  在方法执行之前验证用户是否有效。

  在方法执行之后，打印方法的执行耗时。

  在方法抛出异常后，记录异常信息发送到mq。

- 切入点(Pointcut )

  用来指定需要将通知使用到哪些地方，比如需要用在哪些类的哪些方法上，切入点就是做这个配置的。

- 切面（Aspect）

  通知（Advice）和切入点（Pointcut）的组合。切面来定义在哪些地方（Pointcut）执行什么操作（Advice）。

- 顾问（Advisor)

  Advisor 其实它就是 Pointcut 与 Advice 的组合，Advice 是要增强的逻辑，而增强的逻辑要在什么地方执行是通过Pointcut来指定的，所以 Advice 必需与 Pointcut 组合在一起，这就诞生了 Advisor 这个类，spring Aop中提供了一个Advisor接口将Pointcut 与 Advice 的组合起来。

  Advisor有好几个称呼：顾问、通知器。

## 五、事务

spring 使用事务的两种方式：

- `编程式事务`:硬编码的方式
- `声明式事务`:@Transaction的方式

### 5.1 编程式事务

### 5.2 声明式事务

所谓声明式事务，就是通过配置的方式，比如通过配置文件（xml）或者注解的方式，告诉spring，哪些方法需要spring帮忙管理事务，然后开发者只用关注业务代码，而事务的事情spring自动帮我们控制。

#### 5.2.1 相关注解

- @EnableTransactionManagement
  :::note
  当spring容器启动的时候，发现有@EnableTransactionManagement注解，此时会拦截所有bean的创建，扫描看一下bean上是否有@Transaction注解（类、或者父类、或者接口、或者方法中有这个注解都可以），如果有这个注解，spring会通过aop的方式给bean生成代理对象，代理对象中会增加一个拦截器，拦截器会拦截bean中public方法执行，会在方法执行之前启动事务，方法执行完毕之后提交或者回滚事务。
  :::

  - 定义事务管理器
    事务交给spring管理，那么你肯定要创建一个或者多个事务管理者，有这些管理者来管理具体的事务，比如启动事务、提交事务、回滚事务，这些都是管理者来负责的。

  spring中使用PlatformTransactionManager这个接口来表示事务管理者。

  PlatformTransactionManager多个实现类，用来应对不同的环境

  1. JpaTransactionManager：如果你用jpa来操作db，那么需要用这个管理器来帮你控制事务。
  2. DataSourceTransactionManager：如果你用是指定数据源的方式，比如操作数据库用的是：JdbcTemplate、mybatis ibatis，那么需要用这个管理器来帮你控制事务。
  3. HibernateTransactionManager：如果你用hibernate来操作db，那么需要用这个管理器来帮你控制事务
  4. JtaTransactionManager：如果你用的是java中的jta来操作db，这种通常是分布式事务，此时需要用这种管理器来控制事务。

- @Transaction

  需使用事务的目标上加@Transaction注解

  - @Transaction放在接口上，那么接口的实现类中所有public都被spring自动加上事务
  - @Transaction放在类上，那么当前类以及其下无限级子类中所有pubilc方法将被spring自动加上事务
  - @Transaction放在public方法上，那么该方法将被spring自动加上事务
  - 注意：@Transaction只对public方法有效



#### 5.2.2 事务的传播行为

事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。

![事务的传播行为](https://cdn.jsdelivr.net/gh/TitoniPine/Images@main/uPic/20220331175105.png)

1. PROPAGATION_REQUIRED