---
title: MySQL
date: 2022-04-10 11:39:05
permalink: /pages/a99400/
---
## 1 基本概述

MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据。



### 1.1 相关概念

**DB**（DataBase）：存储数据的‘仓库’，器本质是一个文件系统。

**DBMS**（DataBase Management System）：是一种用于操作和管理数据库的大型软件。



## 2 SQL语句

结构化查询语言，可==以总结为对数据库、表、表中的数据、索引等的增删改查。==

```SQL
-- 查看已有的数据库
	SHOW DATABASES [ LIKE 'PATTERN']；
	
-- 使用数据库
	USE 库名；	
```

### 2.1 数据操作语言

DML（Data Manipulation Language），主要用于对数据库对象中包含的**数据进行操作**。

- `insert` 向数据库中插入一条数据
- `delete` 删除表中的一条或者多条记录
- `update` 修改表中的数据

```SQL
-- 对表中数据的增删改
INSERT INTO 表(列名,....) VALUES (值,...);

DELETE FROM 表 WHERE 条件;
	TRUNCATE 表; --这是清空整个表

UPDATE 表名 SET 字段名=值,...;
```

### 2.2 数据定义语言

DDL（Data Definition Language），主要用于**维护存储数据的结构**，这种结构包括数据库，表、视图、索引、同义词、聚簇等。

- `create` 创建数据库和数据库的一些对象。
- `drop` 删除数据库/表、索引、条件约束以及数据表的权限等。
- `alter` 修改数据库表的定义及数据属性。



### 2.3 数据查询语言

DQL （Data Query Language） ，主要用于**查询**数据库当中的数据。

- `selete` 查询表中的数据

- `from` 查询哪张表、视图

- `where` 约束条件

  #### 2.3.1 简单查询

  ```SQL
  -- 1、查询全表、
  	SELECT * FROM 表名;
  -- 2、指定字段查询
  	SELECT 字段1,字段2,...FROM 表名;
  -- 3、别名查询
  	SELECT 字段名 AS '别名',...FROM 表名 AS '表别名';
  -- 4、去重查询
  	-- 去除重复的行
  	SELECT DISTINCT * FROM 表名;
  	-- 去除重复的列
  	SELECT DISTINCT 字段名 FROM 表名;
  ```

  #### 2.3.2 运算符操作

  ```SQL
  -- 1、+ - * / 算术运算符
  	select price * 1.1 from product;
  -- 2、> >= < <= != 比较运算符
  	-- 查询价格为800商品
  	select * from product where price = 800;
  -- 3、&& || 逻辑运算符
  	-- 查询商品价格是200或800的所有商品
  	select * from product where price in(200,800);
  	select * from product where price = 200 or price = 800;
  	select * from product where price = 200 || price = 800;
  -- 4、& ^ << >> ~ 位运算符
  ```

  #### 2.3.3 排序查询 order by

  ```SQL
  -- 1、升序排列,默认升序 ASC
  	SELECT * FROM product ORDER BY price [ASC];
  -- 2、降序排列
  	SELECT * FROM product ORDER BY price DESC;
  	SELECT * FROM product ORDER BY price DESC, category_id DESC;
  ```

  #### 2.3.4 聚合查询

  ```SQL
  -- 有 null 值，不会进行统计。
  -- count、sum、max、min、avg
  ```

  #### 2.3.5 分组查询 group by

  ```SQL
  -- 分组可以理解将一张表拆分成多张表，拆分的依据就是分组字段。
  -- 分组后的条件筛选用 HAVING
  ```

  #### 2.3.6 分页显示 limit

  ```SQL
  -- 1、查询 product 表的前5条记录
  	SELECT * FROM product LIMIT 5;
  -- 1、从第4条开始显示，显示5条
  	SELECT * FROM product LIMIT 3,5;
  ```

  #### 2.3.7 SQL语句的执行顺序

  FROM -> WHERE -> GROUP BY -> COUNT -> HAVING -> SELECT -> ORDER BY -> LIMIT 

### 2.4 数据控制语言

DCL（Data Control Language），主要控制数据库对象的**权限管理**、**事务**和**实时监视**。

- `grant`分配权限给用户
- `revoke`废除数据库中某用户的权限
- `rollback` 退回到某一点 (回滚）
- `commit` 提交

#### 2.4.1 创建用户

```SQL
CREATE USER 'username'@'%' IDENTIFIED BY 'password';
```

% 表示所有的 host 都可以连接，通常为了安全，设置为你允许连接的主机 ip。

#### 2.4.2 赋予用户对数据库的权限

```sql
GRANT ALL PRIVILEGES ON 数据库.* TO 'username'@'%';
```

GRANT `CREATE, ALTER, DROP, INSERT, UPDATE, DELETE, SELECT, REFERENCES, RELOAD` on *.* TO 'sammy'@'localhost' WITH GRANT OPTION;

#### 2.4.3 刷新权限表

```SQL
FLUSH PRIVILEGES;
```

#### 2.4.5 收回权限

REVOKE

### 2.4 事务控制语言

## 3 约束

### 3.1 主键约束

能唯一标识记录的字段，可以作为主键。

> - 一个表只能有一个主键。
> - 主键具有唯一性。
> - 声明字段时，用 primary key 标识。也可以在字段列表之后声明
>       例：create table tab ( id int, stu varchar(10), primary key (id));
> - 主键字段的值不能为null。
> - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。
>   例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));

### 3.2 唯一约束

UNIQUE 使得某字段的值也不能重复。

### 3.3 NULL 约束

null不是数据类型，是列的一个属性。表示当前列是否可以为null，表示什么都没有。

> ​    null, 允许为空。默认。
> ​    not null, 不允许为空。
> ​    insert into tab values (null, 'val');
> ​        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null

### 3.4  DEFAULT 约束

 当前字段的默认值。

### 3.5 自增长约束

AUTO_INCREMENT 

> 自动增长必须为索引（主键或unique）
> 只能存在一个字段为自动增长。
> 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;

### 3.6 外键约束

用于限制主表与从表数据完整性。存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。

## 4 三大范式

**1NF(第一范式)**

属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。**1NF 是所有关系型数据库的最基本要求** ，也就是说关系型数据库中创建的表一定满足第一范式。

**2NF(第二范式)**

2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。

一些重要的概念：

- **函数依赖（functional dependency）** ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。
- **部分函数依赖（partial functional dependency）** ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号）；
- **完全函数依赖(Full functional dependency)** ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；
- **传递函数依赖** ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。

**3NF(第三范式)**

3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。

## 5 视图

视图是一个==虚拟表==，本身并不拥有数据，占用很少的内存。视图基于已有的表。

- 视图的创建和删除只会影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改的操作时，数据表中的数据会相应的发生变化，反之亦然。
- 向视图提供的数据内容语句为 SELECT 语句时，可以将视图理解为存储起来的 SELECT 语句。
- 视图，是向用户提供基表数据的另一种表现形式。在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，他==可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。==

### 5.1 创建视图

- 在 CREATE VIEW 语句中嵌入子查询

### 5.2 查看视图

### 5.3 更新视图数据与视图的删除

## 6 存储过程与存储函数

可以将复杂的SQL逻辑封装到一起。

### 6.1 存储过程

是一组经过预先编译的SQL语句的封装。执行过程：存储过程预先存储在MySQL服务器上，需要执行时，客户端只需要向服务器发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列SQL语句全部执行。

### 6.2 存储函数

## 7 触发器（事件）

## 8 SQL的执行流程

![20220312202413](https://cdn.jsdelivr.net/gh/TitoniPine/Images@main/uPic/20220312202413.png)

Java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，每个请求都是新建连接和销毁连接，这样势必会造成不必要的浪费和性能的下降。通过==数据库连接池==提供一些固定的用来连接的线程，避免连接的频繁创建和销毁。



线程获取 SQL 语句 -> 交给 **SQL接口**处理 -> **SQL解析器**处理SQL语句 -> 解析过的SQL语句由**查询优化器**来优化 -> **执行器**调用**存储引擎**的接口去完成SQL执行



### 8.1 存储引擎

InnoDB：事务型数据库的首选，支持ACID，支持行锁，表锁，外键。

MylSAM：基于ISAM的存储引擎，MyISAM 拥有较高的插入、查询速度，但不支持事务，只支持表锁。

MEMORY：将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。



InnoDB中的一个重要的组件：**缓冲池 Buffer Pool**

- MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。
- MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。
- 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

#### 锁机制

**InnoDB 行锁的实现方式**

**InnoDB行锁是通过给索引上的索引项加锁来实现的，**这一点[MySQL](https://cloud.tencent.com/product/cdb?from=10680)与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：**只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！**

**表级锁和行级锁对比：**

- **表级锁：** MySQL 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。
- **行级锁：** MySQL 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

#### 锁算法

- Record lock：记录锁，单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身

#### 缓冲池

第一次查询的时候会将查询的结果存到 Buffer Pool 中，这样后面再有请求的时候，就会先从缓冲池中去查询，如果没有再去磁盘中查找，然后再放到 Buffer Pool 中。

#### Undo 日志

在一条数据被加载到 Buffer Pool 中的同时会在 undo日志中记录更新前的值

#### redo 日志

redo 记录的是数据修改之后的值，不管事务是否提交都会记录下来，一般情况下，redo log Buffer 数据写入磁盘的策略是立即刷入磁盘



#### 到此为止，从==执行器开始调用存储引擎==接口做了哪些事情呢？

1.准备更新一条 SQL 语句

2.MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中 

3.在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中

4.innodb 会在 Buffer Pool 中执行更新操作

5.更新后的数据会记录在 redo log buffer 中

6.MySQL 提交事务的时候，会将 redo log buffer 中的数据写入到 redo 日志文件中 刷磁盘可以通过 innodb_flush_log_at_trx_commit 参数来设置

值为 0 表示不刷入磁盘

值为 1 表示立即刷入磁盘

值为 2 表示先刷到 os cache

7.myslq 重启的时候会将 redo 日志恢复到缓冲池中



#### bin log 日志文件

MySQL级别的，所有的存储引擎都可以使用，记录整个操作过程。适用于主从复制和数据恢复。



## 9 事务

### 9.1 事务的特性

ACID：

1. **原子性**（`Atomicity`） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性**（`Consistency`）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. **隔离性**（`Isolation`）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性**（`Durabilily`）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 9.2 数据事务的实现原理

我们这里以 MySQL 的 InnoDB 引擎为例来简单说一下。

MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。

MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。

保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

### 9.3 并发事务带来的问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
- **不可重复读（Unrepeatable read）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**不可重复读和幻读区别：**

不可重复读的重点是**修改**比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于**新增或者删除**比如多次读取一条记录发现记录增多或减少了。

### 9.4 事务的隔离级别

SQL 标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。

- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。

- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。

- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

  |     隔离级别     | 脏读 | 不可重复读 | 幻读 |
  | :--------------: | :--: | :--------: | :--: |
  | READ-UNCOMMITTED |  √   |     √      |  √   |
  |  READ-COMMITTED  |  ×   |     √      |  √   |
  | REPEATABLE-READ  |  ×   |     ×      |  √   |
  |   SERIALIZABLE   |  ×   |     ×      |  ×   |

  **MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。**

  因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ-COMMITTED(读取提交内容)** ，但是你要知道的是 InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）** 并不会有任何性能损失。

  InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(可串行化)** 隔离级别。

## 10 索引

**索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。**

索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。

### 10.1 优缺点

**优点** ：

- 使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

**缺点** ：

- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。

### 10.2 索引的底层数据结构

##### Hash表 & B+树

哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。

**为何能够通过 key 快速取出 value呢？** 原因在于 **哈希算法**（也叫散列算法）。通过哈希算法，我们可以快速找到 value 对应的 index，找到了 index 也就找到了对应的 value。

但是！哈希算法有个 **Hash 冲突** 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 **链地址法**。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 `HashMap` 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后`HashMap`为了减少链表过长的时候搜索时间过长引入了红黑树。

既然哈希表这么快，**为什么MySQL 没有使用其作为索引的数据结构呢？**

**1.Hash 冲突问题** ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。

**2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：** 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。

##### B 树& B+树

B 树也称 B-树,全称为 **多路平衡查找树** ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 `Balanced` （平衡）的意思。

目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。

**B 树& B+树两者有何异同呢？**

- B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
- B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。

### 10.3 索引类型

##### 主键索引(Primary Key)

数据表的主键列使用的就是主键索引。

一张数据表有只能有一个主键，并且主键不能为 null，不能重复。

在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。

##### 二级索引(辅助索引)

**二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。**

唯一索引，普通索引，前缀索引等索引属于二级索引。

1. **唯一索引(Unique Key)** ：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
2. **普通索引(Index)** ：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。**
3. **前缀索引(Prefix)** ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，
   因为只取前几个字符。
4. **全文索引(Full Text)** ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。

##### 聚集索引与非聚集索引

###### 聚集索引

**聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。**

在 Mysql 中，InnoDB 引擎的表的 `.ibd`文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

###### 聚集索引的优点

聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。

###### 聚集索引的缺点

1. **依赖于有序的数据** ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
2. **更新代价大** ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，
   而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，
   所以对于主键索引来说，主键一般都是不可被修改的。

###### 非聚集索引

**非聚集索引即索引结构和数据分开存放的索引。**

**二级索引属于非聚集索引。**

###### 非聚集索引的优点

**更新代价比聚集索引要小** 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的

###### 非聚集索引的缺点

1. 跟聚集索引一样，非聚集索引也依赖于有序的数据
2. **可能会二次查询(回表)** :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

### 10.4 创建索引的注意事项

**1.选择合适的字段创建索引：**

- **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段** ：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

**2.被频繁更新的字段应该慎重建立索引。**

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。
如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

**3.尽可能的考虑建立联合索引而不是单列索引。**

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

**4.注意避免冗余索引** 。

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

**5.考虑在字符串类型的字段上使用前缀索引代替普通索引。**

前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。



## 11 InnoDB的锁机制和MVCC

### 11.1 MVCC

