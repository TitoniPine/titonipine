<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Spring | Plum Blossom</title>
    <meta name="generator" content="VuePress 1.9.2">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="知识管理">
    <meta name="keywords" content="vuepress,theme,blog,vdoing">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.d4aaf2aa.css" as="style"><link rel="preload" href="/assets/js/app.452883b7.js" as="script"><link rel="preload" href="/assets/js/2.56fd5cb0.js" as="script"><link rel="preload" href="/assets/js/9.ba92e156.js" as="script"><link rel="prefetch" href="/assets/js/10.e34745fa.js"><link rel="prefetch" href="/assets/js/11.0c5a5f56.js"><link rel="prefetch" href="/assets/js/12.e37a3bae.js"><link rel="prefetch" href="/assets/js/13.dec75161.js"><link rel="prefetch" href="/assets/js/14.f78337c3.js"><link rel="prefetch" href="/assets/js/15.99acbeb8.js"><link rel="prefetch" href="/assets/js/16.b65d0402.js"><link rel="prefetch" href="/assets/js/17.4d622483.js"><link rel="prefetch" href="/assets/js/18.5d6d74a0.js"><link rel="prefetch" href="/assets/js/3.5ae67027.js"><link rel="prefetch" href="/assets/js/4.cb2134f5.js"><link rel="prefetch" href="/assets/js/5.807ea28e.js"><link rel="prefetch" href="/assets/js/6.0d59ddfa.js"><link rel="prefetch" href="/assets/js/7.7d78bfbd.js"><link rel="prefetch" href="/assets/js/8.a96fa62e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d4aaf2aa.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://cdn.jsdelivr.net/gh/TitoniPine/Images@main/uPic/cat1.png" alt="Plum Blossom" class="logo"> <span class="site-name can-hide">Plum Blossom</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/52d5c3/" class="nav-link">基础</a></div><div class="nav-item"><a href="/pages/ce6c78/" class="nav-link">框架</a></div><div class="nav-item"><a href="/pages/db78e2/" class="nav-link">工具</a></div><div class="nav-item"><a href="/pages/5d571c/" class="nav-link">项目</a></div><div class="nav-item"><a href="/pages/9cc27d/" class="nav-link">☁️</a></div><div class="nav-item"><a href="/pages/1b12ed/" class="nav-link">书籍</a></div> <a href="https://github.com/titonipine" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/52d5c3/" class="nav-link">基础</a></div><div class="nav-item"><a href="/pages/ce6c78/" class="nav-link">框架</a></div><div class="nav-item"><a href="/pages/db78e2/" class="nav-link">工具</a></div><div class="nav-item"><a href="/pages/5d571c/" class="nav-link">项目</a></div><div class="nav-item"><a href="/pages/9cc27d/" class="nav-link">☁️</a></div><div class="nav-item"><a href="/pages/1b12ed/" class="nav-link">书籍</a></div> <a href="https://github.com/titonipine" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Spring</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/5aa973/" aria-current="page" class="active sidebar-link">Spring</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/5aa973/#一、概述" class="sidebar-link">一、概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_1-1-设计理念和核心" class="sidebar-link">1.1 设计理念和核心</a></li><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_1-2-优缺点" class="sidebar-link">1.2 优缺点</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/5aa973/#二、结构" class="sidebar-link">二、结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_2-1-组成模块" class="sidebar-link">2.1 组成模块</a></li><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_2-2-用到的设计模式" class="sidebar-link">2.2 用到的设计模式</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/5aa973/#三、ioc" class="sidebar-link">三、IOC</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_3-1-bean对象的注册" class="sidebar-link">3.1 bean对象的注册</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_3-1-1-configuration-和-bean-的批量注册" class="sidebar-link">3.1.1 @Configuration 和 @Bean 的批量注册</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_3-1-2-componentscan-扫描包" class="sidebar-link">3.1.2 @ComponentScan 扫描包</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_3-1-3-import" class="sidebar-link">3.1.3 @Import</a></li><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_3-2-注解实现依赖注入" class="sidebar-link">3.2 注解实现依赖注入</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_3-2-1-autowired" class="sidebar-link">3.2.1 @Autowired</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_3-2-2-resource" class="sidebar-link">3.2.2 @Resource</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_3-2-3-其他注解" class="sidebar-link">3.2.3 其他注解</a></li><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_3-3-其他注解的作用" class="sidebar-link">3.3 其他注解的作用</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_3-3-1-scope" class="sidebar-link">3.3.1 @Scope</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_3-3-2-dependson" class="sidebar-link">3.3.2 @DependsOn</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_3-3-3-importsource" class="sidebar-link">3.3.3 @ImportSource</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_3-3-4-lazy" class="sidebar-link">3.3.4 @Lazy</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_3-3-5-value" class="sidebar-link">3.3.5 @Value</a></li><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_3-4-bean的生命周期" class="sidebar-link">3.4 bean的生命周期</a></li><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_3-5-bean循环依赖" class="sidebar-link">3.5 Bean循环依赖</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/5aa973/#四、aop" class="sidebar-link">四、AOP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_4-1-代理" class="sidebar-link">4.1 代理</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_4-1-1-静态代理" class="sidebar-link">4.1.1 静态代理</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_4-1-2-动态代理" class="sidebar-link">4.1.2 动态代理</a></li><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_4-2-aop的一些概念" class="sidebar-link">4.2 AOP的一些概念</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/5aa973/#五、事务" class="sidebar-link">五、事务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_5-1-编程式事务" class="sidebar-link">5.1 编程式事务</a></li><li class="sidebar-sub-header level3"><a href="/pages/5aa973/#_5-2-声明式事务" class="sidebar-link">5.2 声明式事务</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_5-2-1-相关注解" class="sidebar-link">5.2.1 相关注解</a></li><li class="sidebar-sub-header level4"><a href="/pages/5aa973/#_5-2-2-事务的传播行为" class="sidebar-link">5.2.2 事务的传播行为</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>安全框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ce6c78/" class="sidebar-link">JWT</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Mybatis</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>SpringBoot</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>web</span> <!----></p> <!----></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>非关系型数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/9a6634/" class="sidebar-link">Redis</a></li><li><a href="/pages/0a0365/" class="sidebar-link">Elasticsearch</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>MQ</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c267a5/" class="sidebar-link">RabbitMQ</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-0c557b5e><div class="articleInfo" data-v-0c557b5e><ul class="breadcrumbs" data-v-0c557b5e><li data-v-0c557b5e><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-0c557b5e></a></li> <li data-v-0c557b5e><span data-v-0c557b5e>框架</span></li><li data-v-0c557b5e><span data-v-0c557b5e>Spring</span></li><li data-v-0c557b5e><span data-v-0c557b5e>基础</span></li></ul> <div class="info" data-v-0c557b5e><div title="作者" class="author iconfont icon-touxiang" data-v-0c557b5e><a href="https://github.com/titonipine" target="_blank" title="作者" class="beLink" data-v-0c557b5e>Plum Blossom</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>2022-04-10</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">Spring<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="一、概述"><a href="#一、概述" class="header-anchor">#</a> 一、概述</h2> <p>Spring是一个<code>轻量级的Java开发框架</code>，目的是为了解决企业级应用开发的业务逻辑和其他各层的耦合问题。</p> <p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是<strong>依赖注入（dependency injection，DI）</strong> 和 <strong>面向切面编程（aspect-oriented programming，AOP）</strong>。</p> <h3 id="_1-1-设计理念和核心"><a href="#_1-1-设计理念和核心" class="header-anchor">#</a> 1.1 设计理念和核心</h3> <p><strong>Spring设计理念</strong>：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；</p> <p><strong>Spring框架的核心</strong>：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p> <h3 id="_1-2-优缺点"><a href="#_1-2-优缺点" class="header-anchor">#</a> 1.2 优缺点</h3> <ul><li><p>优点：</p> <ol><li>方便解耦，简化开发</li> <li>AOP编程的支持</li> <li>声明式事务的支持</li> <li>方便程序的测试</li> <li>方便集成各种优秀框架</li> <li>降低JavaEE API的使用难度</li></ol></li> <li><p>缺点：</p> <ol><li>Spring依赖反射，反射影响性能</li></ol></li></ul> <h2 id="二、结构"><a href="#二、结构" class="header-anchor">#</a> 二、结构</h2> <h3 id="_2-1-组成模块"><a href="#_2-1-组成模块" class="header-anchor">#</a> 2.1 组成模块</h3> <p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在<code>核心容器（Core Container）</code> 、<code>AOP（Aspect Oriented Programming）</code>和<code>设备支持（Instrmentation）</code> 、<code>数据访问与集成（Data Access/Integeration）</code> 、 <code>Web</code>、 <code>消息（Messaging）</code> 、 <code>Test</code>等 6 个模块中。 以下是 Spring 5 的模块结构图：</p> <p><img src="https://cdn.jsdelivr.net/gh/TitoniPine/Images@main/uPic/20220330185614.png" alt="Spring模块结构图"></p> <ul><li>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</li> <li>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</li> <li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li> <li>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</li> <li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li> <li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li> <li>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li></ul> <h3 id="_2-2-用到的设计模式"><a href="#_2-2-用到的设计模式" class="header-anchor">#</a> 2.2 用到的设计模式</h3> <ol><li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li> <li>单例模式：Bean默认为单例模式。</li> <li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li> <li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li> <li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</li></ol> <h2 id="三、ioc"><a href="#三、ioc" class="header-anchor">#</a> 三、IOC</h2> <p>Inversion of Control 它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p> <p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI）），装配对象，配置对象，并且管理这些对象的整个生命周期。</p> <h3 id="_3-1-bean对象的注册"><a href="#_3-1-bean对象的注册" class="header-anchor">#</a> 3.1 bean对象的注册</h3> <h4 id="_3-1-1-configuration-和-bean-的批量注册"><a href="#_3-1-1-configuration-和-bean-的批量注册" class="header-anchor">#</a> 3.1.1 @Configuration 和 @Bean 的批量注册</h4> <p><code>@Configuration</code>加在类上，让这个类的功能等同于一个 bean.xml 配置文件。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>被 @Configuration 修饰的类，spring容器中会通过cglib给这个类创建一个代理，代理会拦截所有被 @Bean 修饰的方法，默认情况（bean为单例）下确保这些方法只被调用一次，从而确保这些bean是同一个bean，即单例的。</p></div> <p><code>@Bean</code>用到方法上，类似于 bean.xml 配置文件中的 bean 元素，用来在 spring 容器中注册一个 bean。</p> <h4 id="_3-1-2-componentscan-扫描包"><a href="#_3-1-2-componentscan-扫描包" class="header-anchor">#</a> 3.1.2 @ComponentScan 扫描包</h4> <p><code>@ComponentScan</code>这个注解会让spring去扫描某些包及其子包中所有的类，然后将满足一定条件的类作为bean注册到spring容器容器中。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>所以玩这个注解，主要关注2个问题：</p> <p>第一个：需要扫描哪些包？通过value、backPackages、basePackageClasses这3个参数来控制</p> <p>第二：过滤器有哪些？通过useDefaultFilters、includeFilters、excludeFilters这3个参数来控制过滤器</p> <p>这两个问题搞清楚了，就可以确定哪些类会被注册到容器中。</p> <p>默认情况下，任何参数都不设置的情况下，此时，会将@ComponentScan修饰的类所在的包作为扫描包；默认情况下useDefaultFilters为true，这个为true的时候，spring容器内部会使用默认过滤器，规则是：凡是类上有@Repository、@Service、@Controller、@Component这几个注解中的任何一个的，那么这个类就会被作为bean注册到spring容器中，所以默认情况下，只需在类上加上这几个注解中的任何一个，这些类就会自动交给spring容器来管理了。</p></div> <h4 id="_3-1-3-import"><a href="#_3-1-3-import" class="header-anchor">#</a> 3.1.3 @Import</h4> <p><code>@Import</code>可以用来批量导入需要注册的各种类，如普通的类、配置类，完后完成普通类和配置类中所有bean的注册。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>@Import的value常见的有5种用法</p> <ol><li>value为普通的类</li> <li>value为@Configuration标注的类</li> <li>value为@CompontentScan标注的类</li> <li>value为ImportBeanDefinitionRegistrar接口类型</li> <li>value为ImportSelector接口类型</li> <li>value为DeferredImportSelector接口类型</li></ol></div> <h3 id="_3-2-注解实现依赖注入"><a href="#_3-2-注解实现依赖注入" class="header-anchor">#</a> 3.2 注解实现依赖注入</h3> <h4 id="_3-2-1-autowired"><a href="#_3-2-1-autowired" class="header-anchor">#</a> 3.2.1 @Autowired</h4> <p>实现依赖注入，spring容器会对bean中所有<code>字段、方法</code>进行遍历，标注有@Autowired注解的，都会进行注入。</p> <p>多个参数的时候，方法上面的@Autowire默认对方法中所有参数起效，如果我们想对某个参数进行特定的配置，<strong>可以在参数上加上@Autowired(required = false)</strong>，这个配置会覆盖方法上面的@Autowired配置。</p> <p><strong>required为false：表示这个bean不是强制注入的，能找到就注入，找不到就注入一个null对象</strong></p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>@Autowired 查找候选者的过程</p> <p>按类型找-&gt;通过限定符@Qualifier过滤-&gt;@Primary-&gt;@Priority-&gt;根据名称找（字段名称或者方法名称）</p></div> <h4 id="_3-2-2-resource"><a href="#_3-2-2-resource" class="header-anchor">#</a> 3.2.2 @Resource</h4> <p>和@Autowired注解类似，也是用来注入依赖的对象的，spring容器会对bean中所有字段、方法进行遍历，标注有@Resource注解的，都会进行注入。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>@Resource 查找候选者的过程</p> <p>先按Resource的name值作为bean名称找-&gt;按名称（字段名称、方法名称、set属性名称）找-&gt;按类型找-&gt;通过限定符@Qualifier过滤-&gt;@Primary-&gt;@Priority-&gt;根据名称找（字段名称或者方法参数名称）</p></div> <h4 id="_3-2-3-其他注解"><a href="#_3-2-3-其他注解" class="header-anchor">#</a> 3.2.3 其他注解</h4> <ul><li>@Qualifier：可以在依赖注入查找候选者的过程中对候选者进行过滤。用在类、字段、方法和方法参数上</li> <li>@Primary：设置为主要候选者</li></ul> <h3 id="_3-3-其他注解的作用"><a href="#_3-3-其他注解的作用" class="header-anchor">#</a> 3.3 其他注解的作用</h3> <h4 id="_3-3-1-scope"><a href="#_3-3-1-scope" class="header-anchor">#</a> 3.3.1 @Scope</h4> <p>指定bean的作用域。</p> <p>用法：</p> <ol><li>和@Compontent一起使用在类上</li> <li>和@Bean一起标注在方法上</li></ol> <h4 id="_3-3-2-dependson"><a href="#_3-3-2-dependson" class="header-anchor">#</a> 3.3.2 @DependsOn</h4> <p>指定当前bean依赖的bean，@DependsOn可以指定当前bean依赖的bean，通过这个可以确保@DependsOn指定的bean在当前bean创建之前先创建好</p> <p>用法：</p> <ol><li>和@Compontent一起使用在类上</li> <li>和@Bean一起标注在方法上</li></ol> <h4 id="_3-3-3-importsource"><a href="#_3-3-3-importsource" class="header-anchor">#</a> 3.3.3 @ImportSource</h4> <p>配置类中导入bean定义的配置文件，有些项目，前期可能采用xml的方式配置bean，后期可能想采用spring注解的方式来重构项目，但是有些老的模块可能还是xml的方式，spring为了方便在注解方式中兼容老的xml的方式，提供了@ImportResource注解来引入bean定义的配置文件。</p> <h4 id="_3-3-4-lazy"><a href="#_3-3-4-lazy" class="header-anchor">#</a> 3.3.4 @Lazy</h4> <p>延迟初始化，@Lazy等效于bean xml中bean元素的lazy-init属性，可以实现bean的延迟初始化。</p> <p>用法：</p> <ol><li>和@Compontent一起标注在类上，可以是这个类延迟初始化</li> <li>和@Configuration一起标注在配置类中，可以让当前配置类中通过@Bean注册的bean延迟初始化</li> <li>和@Bean一起使用，可以使当前bean延迟初始化</li></ol> <h4 id="_3-3-5-value"><a href="#_3-3-5-value" class="header-anchor">#</a> 3.3.5 @Value</h4> <p>@Value可以标注在字段上面，可以引入外部配置文件中的数据，比如可以将数据库的一些配置信息放在配置文件中，然后通过@Value的方式将其注入到bean的一些字段中</p> <h3 id="_3-4-bean的生命周期"><a href="#_3-4-bean的生命周期" class="header-anchor">#</a> 3.4 bean的生命周期</h3> <ol><li><p><strong>将各种方式定义的bean的信息，解析成BeanDefinition对象,注册到spring容器中</strong>。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>BeanDefinition里面里面包含了bean定义的各种信息，如：bean对应的class、scope、lazy信息、dependOn信息、autowireCandidate（是否是候选对象）、primary（是否是主要的候选者）等信息。</p></div></li> <li><p>bean 的注册</p> <p>bean注册阶段需要用到一个非常重要的接口：<code>BeanDefinitionRegistry</code></p> <p>BeanDefinitionRegistry唯一实现：<code>DefaultListableBeanFactory</code></p></li> <li><p><strong>BeanDefinition合并阶段</strong></p> <p>可能我们定义bean的时候有父子bean关系，此时子BeanDefinition中的信息是不完整的，比如设置属性的时候配置在父BeanDefinition中，此时子BeanDefinition中是没有这些信息的，需要将子bean的BeanDefinition和父bean的BeanDefinition进行合并，得到最终的一个RootBeanDefinition，合并之后得到的RootBeanDefinition包含bean定义的所有信息，包含了从父bean中继继承过来的所有信息，后续bean的所有创建工作就是依靠合并之后BeanDefinition来进行的。</p></li> <li><p><strong>Bean Class加载阶段</strong>
这个阶段就是将bean的class名称转换为Class类型的对象。此时会对阶段3中合并产生的<code>RootBeanDefinition</code>中的<code>beanClass</code>进行解析，将bean的类名转换为<code>Class对象</code>，然后赋值给<code>beanClass</code>字段。</p></li> <li><p><strong>通过反射调用bean的构造器，实例化bean</strong></p> <p><code>Bean实例化前操作</code></p> <p>先来看一下<code>DefaultListableBeanFactory</code>，这个类中有个非常非常重要的字段：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanPostProcessor</span><span class="token punctuation">&gt;</span></span> beanPostProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>是一个<code>BeanPostProcessor</code>类型的集合</p> <p><strong>BeanPostProcessor是一个接口，还有很多子接口，这些接口中提供了很多方法，spring在bean生命周期的不同阶段，会调用上面这个列表中的BeanPostProcessor中的一些方法，来对生命周期进行扩展，bean生命周期中的所有扩展点都是依靠这个集合中的BeanPostProcessor来实现的，所以如果大家想对bean的生命周期进行干预，这块一定要掌握好。</strong></p> <p><strong>注意：本文中很多以BeanPostProcessor结尾的，都实现了BeanPostProcessor接口，有些是直接实现的，有些是实现了它的子接口。</strong></p> <p>Bean实例化之前会调用一段代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">applyBeanPostProcessorsBeforeInstantiation</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> beanClass<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BeanPostProcessor</span> bp <span class="token operator">:</span> <span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>bp <span class="token keyword">instanceof</span> <span class="token class-name">InstantiationAwareBeanPostProcessor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">InstantiationAwareBeanPostProcessor</span> ibp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationAwareBeanPostProcessor</span><span class="token punctuation">)</span> bp<span class="token punctuation">;</span>
                <span class="token class-name">Object</span> result <span class="token operator">=</span> ibp<span class="token punctuation">.</span><span class="token function">postProcessBeforeInstantiation</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>这段代码在bean实例化之前给开发者留了个口子，开发者自己可以在这个地方直接去创建一个对象作为bean实例，而跳过spring内部实例化bean的过程。</p> <p>上面代码中轮询<code>beanPostProcessors</code>列表，如果类型是<code>InstantiationAwareBeanPostProcessor</code>， 尝试调用<code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>获取bean的实例对象，如果能够获取到，那么将返回值作为当前bean的实例，那么spring自带的实例化bean的过程就被跳过了。</p> <p><code>postProcessBeforeInstantiation</code>方法如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">default</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInstantiation</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> beanClass<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>这个地方给开发者提供了一个扩展点，允许开发者在这个方法中直接返回bean的一个实例。</p></blockquote> <p>实际上，在实例化前阶段对bean的创建进行干预的情况，用的非常少，所以大部分bean的创建还会继续走下面的阶段。</p> <p><code>Bean实例化操作</code></p> <p><strong>这个过程可以干什么？</strong></p> <p>这个过程会通过反射来调用bean的构造器来创建bean的实例。</p> <p>具体需要使用哪个构造器，spring为开发者提供了一个接口，允许开发者自己来判断用哪个构造器。</p> <p>看一下这块的代码逻辑：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BeanPostProcessor</span> bp <span class="token operator">:</span> <span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bp <span class="token keyword">instanceof</span> <span class="token class-name">SmartInstantiationAwareBeanPostProcessor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SmartInstantiationAwareBeanPostProcessor</span> ibp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SmartInstantiationAwareBeanPostProcessor</span><span class="token punctuation">)</span> bp<span class="token punctuation">;</span>
        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ctors <span class="token operator">=</span> ibp<span class="token punctuation">.</span><span class="token function">determineCandidateConstructors</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ctors <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> ctors<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>会调用<code>SmartInstantiationAwareBeanPostProcessor接口的determineCandidateConstructors</code>方法，这个方法会返回候选的构造器列表，也可以返回空，看一下这个方法的源码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">default</span> <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">determineCandidateConstructors</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> beanClass<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span>
<span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>

    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个方法有个比较重要的实现类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span>AutowiredAnnotationBeanPostProcessor</span>
</code></pre></div><p>可以将<code>@Autowired</code>标注的方法作为候选构造器返回。</p></li> <li><p><strong>bean的属性填充</strong></p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>Bean 属性赋值前会调用<code>InstantiationAwareBeanPostProcessor</code>接口的<code>postProcessProperties</code>方法</p> <p>Bean 属性赋值阶段，这个过程比较简单了，循环处理PropertyValues中的属性值信息，<strong>通过反射调用set方法将属性的值设置到bean实例中。</strong></p></div></li> <li><p><strong>bean的初始化阶段</strong></p> <ul><li><p>Bean Aware 接口回调</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeAwareMethods</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> bean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">Aware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">BeanNameAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">BeanNameAware</span><span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBeanName</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">BeanClassLoaderAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">ClassLoader</span> bcl <span class="token operator">=</span> <span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>bcl <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">BeanClassLoaderAware</span><span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBeanClassLoader</span><span class="token punctuation">(</span>bcl<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">BeanFactoryAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">BeanFactoryAware</span><span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">AbstractAutowireCapableBeanFactory</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>如果我们的bean实例实现了上面的接口，会按照下面的顺序依次进行调用：</p> <div class="language- extra-class"><pre class="language-text"><code>BeanNameAware：将bean的名称注入进去
BeanClassLoaderAware：将BeanClassLoader注入进去
BeanFactoryAware：将BeanFactory注入进去
</code></pre></div></li> <li><p>初始化前</p> <p>会调用BeanPostProcessor的postProcessBeforeInitialization方法，若返回null，当前方法将结束。</p></li> <li><p>初始化阶段</p> <p>2个步骤</p> <ol><li>调用InitializingBean接口的afterPropertiesSet方法</li> <li>调用定义bean的时候指定的初始化方法（@Bean(initMethod = &quot;初始化的方法&quot;)）。</li></ol></li> <li><p>初始化后</p> <p>调用BeanPostProcessor接口的postProcessAfterInitialization方法，返回null的时候，会中断上面的操作。</p></li></ul></li> <li><p><strong>bean的使用阶段</strong></p></li> <li><p><strong>bean的销毁阶段</strong></p> <div class="custom-block note"><p class="custom-block-title">笔记</p> <ol start="3"><li><p>触发bean销毁的几种方式:</p></li> <li><p>调用org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#destroyBean</p></li> <li><p>调用org.springframework.beans.factory.config.ConfigurableBeanFactory#destroySingletons</p></li> <li><p>调用ApplicationContext中的close方法</p></li></ol> <p>Bean销毁阶段会依次执行</p> <ol><li>轮询beanPostProcessors列表，如果是DestructionAwareBeanPostProcessor这种类型的，会调用其内部的postProcessBeforeDestruction方法</li> <li>如果bean实现了org.springframework.beans.factory.DisposableBean接口，会调用这个接口中的destroy方法</li> <li>调用bean自定义的销毁方法(@Bean(destroyMethod = &quot;销毁的方法&quot;))</li></ol></div></li></ol> <h3 id="_3-5-bean循环依赖"><a href="#_3-5-bean循环依赖" class="header-anchor">#</a> 3.5 Bean循环依赖</h3> <p>多个bean之间相互依赖，形成了一个闭环。</p> <p>检测循环依赖：检测循环依赖比较简单，使用一个列表来记录正在创建中的bean，bean创建之前，先去记录中看一下自己是否已经在列表中了，如果在，说明存在循环依赖，如果不在，则将其加入到这个列表，bean创建完毕之后，将其再从这个列表中移除。</p> <p>解决循环依赖：</p> <ul><li>构造器的循环依赖无法解决</li> <li>只有单例的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。</li></ul> <h2 id="四、aop"><a href="#四、aop" class="header-anchor">#</a> 四、AOP</h2> <p>面向切面编程，spring中提供的一些非常牛逼的功能都是通过aop实现的，比如下面这些大家比较熟悉的功能</p> <p>spring事务管理：@Transactional</p> <p>spring异步处理：@EnableAsync</p> <p>spring缓存技术的使用：@EnableCaching</p> <p>spring中各种拦截器：@EnableAspectJAutoProxy</p> <h3 id="_4-1-代理"><a href="#_4-1-代理" class="header-anchor">#</a> 4.1 代理</h3> <h4 id="_4-1-1-静态代理"><a href="#_4-1-1-静态代理" class="header-anchor">#</a> 4.1.1 静态代理</h4> <h4 id="_4-1-2-动态代理"><a href="#_4-1-2-动态代理" class="header-anchor">#</a> 4.1.2 动态代理</h4> <ul><li><p>JDK 动态代理</p> <p>jdk中为实现代理提供了支持，主要用到2个类：</p> <div class="language- extra-class"><pre class="language-text"><code>java.lang.reflect.Proxy
java.lang.reflect.InvocationHandler
</code></pre></div><ul><li><p>proxy</p> <p>里面的一些重要的静态方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//为指定的接口创建代理类，返回代理类的Class对象</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getProxyClass</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> interfaces<span class="token punctuation">)</span>
<span class="token comment">//创建代理类的实例对象</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span>
                                      <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span>
                                      <span class="token class-name">InvocationHandler</span> h<span class="token punctuation">)</span>
<span class="token comment">//判断指定的类是否是一个代理类</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isProxyClass</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> cl<span class="token punctuation">)</span>
<span class="token comment">//获取代理对象的InvocationHandler对象</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">InvocationHandler</span> <span class="token function">getInvocationHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">IllegalArgumentException</span>
</code></pre></div><p><code>创建方式一</code>:</p> <div class="custom-block note"><p class="custom-block-title">笔记</p> <ol><li>调用Proxy.getProxyClass方法获取代理类的Class对象</li> <li>使用InvocationHandler接口创建代理类的处理器</li> <li>通过代理类和InvocationHandler创建代理对象</li> <li>上面已经创建好代理对象了，接着我们就可以使用代理对象了</li></ol></div> <p><code>创建方式二</code>:</p> <div class="custom-block note"><p class="custom-block-title">笔记</p> <ol start="5"><li>使用InvocationHandler接口创建代理类的处理器</li> <li>使用Proxy类的静态方法newProxyInstance直接创建代理对象</li> <li>使用代理对象</li></ol></div></li></ul></li></ul> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>JDK动态代理<strong>只能为接口或接口的实现类创建代理类</strong>，不能直接给普通类创建代理类。</p> <p>JDK动态代理是编译时增强。</p></div> <ul><li>CGLIB 动态代理</li></ul> <p>jdk动态代理只能为接口创建代理，使用上有局限性。实际的场景中我们的类不一定有接口，此时如果我们想为普通的类也实现代理功能，我们就需要用到cglib来实现了。</p> <p>cglib是一个强大、高性能的字节码生成库，它用于在运行时扩展Java类和实现接口；本质上它是通过动态的生成一个子类去覆盖所要代理的类（非final修饰的类和方法）。Enhancer可能是CGLIB中最常用的一个类，和jdk中的Proxy不同的是，Enhancer既能够代理普通的class，也能够代理接口。</p> <p><code>创建方式</code>：</p> <div class="custom-block note"><p class="custom-block-title">笔记</p> <ol><li>定义一个类；</li> <li>自定义 MethodInterceptor 并重写 intercept 方法，intercept用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；</li> <li>通过 Enhancer 类的 create()创建代理类；</li></ol></div> <p>特点：</p> <ol><li>cglib弥补了jdk动态代理的不足，jdk动态代理只能为接口创建代理，而cglib非常强大，不管是接口还是类，都可以使用cglib来创建代理</li> <li>cglib创建代理的过程，<strong>相当于创建了一个新的类，可以通过cglib来配置这个新的类需要实现的接口，以及需要继承的父类</strong></li> <li>cglib可以为类创建代理，但是<strong>这个类不能是final类型的</strong>，cglib为类创建代理的过程，<strong>实际上为通过继承来实现的，相当于给需要被代理的类创建了一个子类，然后会重写父类中的方法，来进行增强</strong>，继承的特性大家应该都知道，final修饰的类是不能被继承的，final修饰的方法不能被重写，static修饰的方法也不能被重写，private修饰的方法也不能被子类重写，而其他类型的方法都可以被子类重写，被重写的这些方法可以通过cglib进行拦截增强</li></ol> <h3 id="_4-2-aop的一些概念"><a href="#_4-2-aop的一些概念" class="header-anchor">#</a> 4.2 AOP的一些概念</h3> <ul><li><p>目标对象(target)</p> <p>目标对象指将要被增强的对象，即包含主业务逻辑的类对象。</p></li> <li><p>连接点(JoinPoint)</p> <p>程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</p> <p>连接点由两个信息确定：</p> <p>方法(表示程序执行点，即在哪个目标方法)</p> <p>相对点(表示方位，即目标方法的什么位置，比如调用前，后等)</p> <p>简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。</p></li> <li><p>代理对象(Proxy)</p> <p>AOP中会通过代理的方式，对目标对象生成一个代理对象，代理对象中会加入需要增强功能，通过代理对象来间接的方式目标对象，起到增强目标对象的效果。</p></li> <li><p>通知(Advice)</p> <p>需要在目标对象中增强的功能，如上面说的：业务方法前验证用户的功能、方法执行之后打印方法的执行日志。</p> <p>通知中有2个重要的信息：方法的什么地方，执行什么操作，这2个信息通过通知来指定。</p> <p>方法的什么地方？之前、之后、包裹目标方法、方法抛出异常后等。</p> <p>如：</p> <p>在方法执行之前验证用户是否有效。</p> <p>在方法执行之后，打印方法的执行耗时。</p> <p>在方法抛出异常后，记录异常信息发送到mq。</p></li> <li><p>切入点(Pointcut )</p> <p>用来指定需要将通知使用到哪些地方，比如需要用在哪些类的哪些方法上，切入点就是做这个配置的。</p></li> <li><p>切面（Aspect）</p> <p>通知（Advice）和切入点（Pointcut）的组合。切面来定义在哪些地方（Pointcut）执行什么操作（Advice）。</p></li> <li><p>顾问（Advisor)</p> <p>Advisor 其实它就是 Pointcut 与 Advice 的组合，Advice 是要增强的逻辑，而增强的逻辑要在什么地方执行是通过Pointcut来指定的，所以 Advice 必需与 Pointcut 组合在一起，这就诞生了 Advisor 这个类，spring Aop中提供了一个Advisor接口将Pointcut 与 Advice 的组合起来。</p> <p>Advisor有好几个称呼：顾问、通知器。</p></li></ul> <h2 id="五、事务"><a href="#五、事务" class="header-anchor">#</a> 五、事务</h2> <p>spring 使用事务的两种方式：</p> <ul><li><code>编程式事务</code>:硬编码的方式</li> <li><code>声明式事务</code>:@Transaction的方式</li></ul> <h3 id="_5-1-编程式事务"><a href="#_5-1-编程式事务" class="header-anchor">#</a> 5.1 编程式事务</h3> <h3 id="_5-2-声明式事务"><a href="#_5-2-声明式事务" class="header-anchor">#</a> 5.2 声明式事务</h3> <p>所谓声明式事务，就是通过配置的方式，比如通过配置文件（xml）或者注解的方式，告诉spring，哪些方法需要spring帮忙管理事务，然后开发者只用关注业务代码，而事务的事情spring自动帮我们控制。</p> <h4 id="_5-2-1-相关注解"><a href="#_5-2-1-相关注解" class="header-anchor">#</a> 5.2.1 相关注解</h4> <ul><li><p>@EnableTransactionManagement</p> <div class="custom-block note"><p class="custom-block-title">笔记</p> <p>当spring容器启动的时候，发现有@EnableTransactionManagement注解，此时会拦截所有bean的创建，扫描看一下bean上是否有@Transaction注解（类、或者父类、或者接口、或者方法中有这个注解都可以），如果有这个注解，spring会通过aop的方式给bean生成代理对象，代理对象中会增加一个拦截器，拦截器会拦截bean中public方法执行，会在方法执行之前启动事务，方法执行完毕之后提交或者回滚事务。</p></div> <ul><li>定义事务管理器
事务交给spring管理，那么你肯定要创建一个或者多个事务管理者，有这些管理者来管理具体的事务，比如启动事务、提交事务、回滚事务，这些都是管理者来负责的。</li></ul> <p>spring中使用PlatformTransactionManager这个接口来表示事务管理者。</p> <p>PlatformTransactionManager多个实现类，用来应对不同的环境</p> <ol><li>JpaTransactionManager：如果你用jpa来操作db，那么需要用这个管理器来帮你控制事务。</li> <li>DataSourceTransactionManager：如果你用是指定数据源的方式，比如操作数据库用的是：JdbcTemplate、mybatis ibatis，那么需要用这个管理器来帮你控制事务。</li> <li>HibernateTransactionManager：如果你用hibernate来操作db，那么需要用这个管理器来帮你控制事务</li> <li>JtaTransactionManager：如果你用的是java中的jta来操作db，这种通常是分布式事务，此时需要用这种管理器来控制事务。</li></ol></li> <li><p>@Transaction</p> <p>需使用事务的目标上加@Transaction注解</p> <ul><li>@Transaction放在接口上，那么接口的实现类中所有public都被spring自动加上事务</li> <li>@Transaction放在类上，那么当前类以及其下无限级子类中所有pubilc方法将被spring自动加上事务</li> <li>@Transaction放在public方法上，那么该方法将被spring自动加上事务</li> <li>注意：@Transaction只对public方法有效</li></ul></li></ul> <h4 id="_5-2-2-事务的传播行为"><a href="#_5-2-2-事务的传播行为" class="header-anchor">#</a> 5.2.2 事务的传播行为</h4> <p>事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。</p> <p><img src="https://cdn.jsdelivr.net/gh/TitoniPine/Images@main/uPic/20220331175105.png" alt="事务的传播行为"></p> <ol><li>PROPAGATION_REQUIRED</li></ol></div></div> <div class="page-slot page-slot-bottom">
  <div class="wwads-cn wwads-horizontal pageB" data-id="136" style="width:100%;max-height:80px;min-height:auto;"></div>
  <style>
    .pageB img{width:80px!important;}
    .wwads-horizontal .wwads-text, .wwads-content .wwads-text{line-height:1;}
  </style>
  </div> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/04/15, 21:19:01</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/pages/ce6c78/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">JWT</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/ce6c78/">JWT</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:hyt10101025@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/titonipine" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2022
    <span>Plum Blossom | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><span class="close-but">×</span> <div>
    <div class="wwads-cn wwads-vertical windowRB" data-id="136" style="max-width:160px;
    min-width: auto;min-height:auto;"></div>
    <style>
      .windowRB{ padding: 0;}
      .windowRB .wwads-img{margin-top: 10px;}
      .windowRB .wwads-content{margin: 0 10px 10px 10px;}
      .custom-html-window-rb .close-but{
        display: none;
      }
    </style>
  </div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.452883b7.js" defer></script><script src="/assets/js/2.56fd5cb0.js" defer></script><script src="/assets/js/9.ba92e156.js" defer></script>
  </body>
</html>
