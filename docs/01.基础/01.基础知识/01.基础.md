---
title: 基础面试题 
date: 2020-05-11 13:59:38 
permalink: /pages/52d5c3 
article: false
---

1. ### Java 语言的特点（如果你简历上有提到 C++ 可能还会问你 Java 和 C++ 的区别）。【⭐⭐】

    - 面向对象（封装，继承，多态）；
    - 平台无关性（ Java 虚拟机实现平台无关性）；
    - 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
    - 可靠性；
    - 安全性；
    - 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；
    - 编译与解释并存；

2. ### 比较 JVM 和 JDK 以及 JRE 。【⭐⭐⭐】非常非常基础的一个问题！学了 Java 之后还不知这个问题如何回答的小伙伴自觉去面壁吧！

    - JVM：是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java
      语言“一次编译，随处可以运行”的关键所在。
    - JDK：它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。
    - JRE：Java的运行时环境，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

3. ### 为什么说 Java 语言“解释与编译并存”。【⭐⭐】

   我们可以将高级编程语言按照程序的执行方式分为两种：

    - **编译型** ：[编译型语言](https://zh.wikipedia.org/wiki/編譯語言)
      会通过[编译器](https://zh.wikipedia.org/wiki/編譯器)将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有
      C、C++、Go、Rust 等等。
    - **解释型**
      ：[解释型语言](https://zh.wikipedia.org/wiki/直譯語言)会通过[解释器](https://zh.wikipedia.org/wiki/直譯器)一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有
      Python、JavaScript、PHP 等等。

   这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java
   解释器来解释执行。

4. ### Java 基本类型有哪几种，各占多少位？【⭐⭐】

   | 基本数据类型         | 占用字节 | 默认值  | 范围            | 包装类    |
         | -------------------- | -------- | ------- | --------------- | --------- |
   | byte(字节型)         | 1        | 0       | -2^7 ~ 2^7-1    | Byte      |
   | short(短整型)        | 2        | 0       | -2^15 ~ 2^15-1  | Short     |
   | int(整型)            | 4        | 0       | -2^31 ~ 2^31-1  | Integer   |
   | long(长整型)         | 8        | 0L      | -2^63 ~ 2^63-1  | Long      |
   | float(浮点型)        | 4        | 0.0f    |                 | Float     |
   | double(双精度浮点型) | 8        | 0.0d    |                 | Double    |
   | char(字符类型)       | 2        | 'u0000' | \u0000 ~ \uffff | Character |
   | boolean(布尔类型)    | 1        | false   | true/false      |           |


5. ### Java 泛型，类型擦除。【⭐⭐⭐】

   泛型：泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的[类型](https://baike.baidu.com/item/类型)，在[实例化](https://baike.baidu.com/item/实例化)时作为参数指明这些类型。

   Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。

   泛型的优点：

    - **编译时的强类型检查**

      泛型要求在声明时指定实际数据类型，Java 编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警。早发现，早治理，把隐患扼杀于摇篮，在编译时发现并修复错误所付出的代价远比在运行时小。

    - **避免了类型转换**

    - **泛型编程可以实现通用算法**

   类型擦除：Java 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 C++ 的模板机制，**Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了**。

   那么，类型擦除做了什么呢？它做了以下工作：

    - 把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。
    - 擦除出现的类型声明，即去掉 `<>` 的内容。比如 `T get()` 方法声明就变成了 `Object get()` ；`List<String>` 就变成了 `List`。如有必要，插入类型转换以保持类型安全。
    - 生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销

   类型通配符：

    - extend 上界通配符：将未知类型限制为该类型的特定类型或其子类。
    - super 下界通配符：将未知类型限制为该类型的特定类型或超类类型。

   **常用的通配符为： T，E，K，V，？**

    - ？ 表示不确定的 Java 类型
    - T (type) 表示具体的一个 Java 类型
    - K V (key value) 分别代表 Java 键值中的 Key Value
    - E (element) 代表 Element

6. ### `==` 和 `equals()` 的区别。【⭐⭐⭐】：这个问题在 2018 年之前几乎是面试必问的问题，但是现在大厂以及比较少问了，现在小厂中厂问的多。

   **`==`** 对于基本类型和引用类型的作用效果是不同的：

    - 对于基本数据类型来说，`==` 比较的是值。
    - 对于引用数据类型来说，`==` 比较的是对象的内存地址。

   > 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

   **`equals()`** 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类，因此所有的类都有`equals()`方法。

   `equals()` 方法存在两种使用情况：

    - **类没有重写 `equals()`方法** ：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。
    - **类重写了 `equals()`方法** ：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

7. ### **`hashCode()`
   和 `equals()`** 【⭐⭐⭐⭐】：这个问题经常问，面试官经常问为什么重写 `equals()` 时要重写 `hashCode()` 方法？另外，这个问题经常结合着 `HashSet` 问。

   `hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。

   `hashCode()`定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是： `Object` 的 `hashCode()` 方法是本地方法，也就是用
   C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。

   其实， `hashCode()` 和 `equals()`都是用于比较两个对象是否相等。

   **那为什么 JDK 还要同时提供这两个方法呢？**

   这是因为在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()` 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进`HastSet`的过程）！

   我们在前面也提到了添加元素进`HastSet`的过程，如果 `HashSet` 在对比的时候，同样的 `hashCode` 有多个对象，它会继续使用 `equals()` 来判断是否真的相同。也就是说 `hashCode`
   帮助我们大大缩小了查找成本。

   **那为什么不只提供 `hashCode()` 方法呢？**

   这是因为两个对象的`hashCode` 值相等并不代表两个对象就相等。

   **那为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？**

   因为 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 `hashCode` )。

   总结下来就是 ：

    - 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。
    - 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
    - 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。

8. ### **重载和重写的区别。** 【⭐⭐⭐⭐】

   重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理

   重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

   重载：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。

   重写：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。**重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。**

   | 区别点     | 重载方法 | 重写方法                                                     |
         | ---------- | -------- | ------------------------------------------------------------ |
   | 发生范围   | 同一个类 | 子类                                                         |
   | 参数列表   | 必须修改 | 一定不能修改                                                 |
   | 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
   | 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
   | 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |
   | 发生阶段   | 编译期   | 运行期                                                       |

   ⭐️ 关于 **重写的返回值类型** 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。

9. ### [深拷贝和浅拷贝](https://developer.aliyun.com/article/617684#:~:text=关于Java的深拷贝和浅拷贝，简单来说就是创建一个和已知对象一模一样的对象。,可能日常编码过程中用的不多，但是这是一个面试经常会问的问题，而且了解深拷贝和浅拷贝的原理，对于Java中的所谓值传递或者引用传递将会有更深的理解。 1、创建对象的5种方式)。【⭐】

   **浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。**

   **深拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。**

10. ### 面向对象和面向过程的区别。【⭐⭐⭐】

    两者的主要区别在于解决问题的方式不同：

    - 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
    - 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。

    另外，面向对象开发的程序一般更易维护、易复用、易扩展。

11. ### 成员变量与局部变量的区别。【⭐⭐⭐】

    - **语法形式** ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public`,`private`,`static`
      等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。
    - **存储方式** ：从变量在内存中的存储方式来看,如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static`
      修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
    - **生存时间** ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
    - **默认值** ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

12. ### 面向对象三大特性是什么。并解释这三大特性。【⭐⭐⭐⭐】

    - 封装：封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

    - 继承

      继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。

      通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

      **关于继承如下 3 点请记住：**

        1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
        2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
        3. 子类可以用自己的方式实现父类的方法。（以后介绍）。

    - 多态

      多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

      **多态的特点:**

        - 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
        - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
        - 多态不能调用“只在子类存在但在父类不存在”的方法；
        - 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。

13. ### **`String`、`StringBuffer` 和 `StringBuilder` 的区别。** 【⭐⭐⭐⭐】

    **可变性**

    在 Java 9 之后，`String` 、`StringBuilder` 与 `StringBuffer` 的实现改用 byte 数组存储字符串。之前用字符数组来存储字符串

    `String` 真正不可变有下面几点原因：

    1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
    2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

    `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。

    **线程安全性**

    `String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

    **性能**

    每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

    **对于三者使用的总结：**

    1. 操作少量的数据: 适用 `String`
    2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
    3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

    对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

14. ### 字符串常量池的作用了解吗？

    **字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

15. ### Java 异常。【⭐⭐⭐】：不会问的特别细。经常的问法是异常可以分为哪几种，然后你答了可检查异常和不可检查异常以后，会让你举例可检查异常有哪些，不可检查有哪些。然后，异常的代码要会写，有一场字节的面试，直接让我写一个把异常捕获了然后抛出去的代码。

    在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类:

    - **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked
      Exception (不受检查异常，可以不处理)。
    - **`Error`** ：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获 。例如Java 虚拟机运行错误（`Virtual MachineError`
      ）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

    **Checked Exception** 即受检查异常，Java 代码在编译过程中，如果受检查异常没有被 `catch`/`throw` 处理的话，就没办法通过编译 。

    除了`RuntimeException`及其子类以外，其他的`Exception`类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、`ClassNotFoundException` 、`SQLException`
    ...。

    **Unchecked Exception** 即 **不受检查异常** ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。

    `RuntimeException` 及其子类都统称为非受检查异常，例如：`NullPointerException`、`NumberFormatException`
    （字符串转换为数字）、`ArrayIndexOutOfBoundsException`（数组越界）、`ClassCastException`（类型转换错误）、`ArithmeticException`（算术错误）等。

    常见的运行时异常。 运行时异常的概念:
    继承自RuntimeException的异常或者其子类， 编译阶段是不会出错的，它是在运行时阶段可能出现的错误， 运行时异常编译阶段可以处理也可以不处理,代码编译都能通过！！

     1.数组索引越界异常: ArrayIndexOutOfBoundsException。 ​ 2.空指针异常 : NullPointerException。 ​ 直接输出没有问题。但是调用空指针的变量的功能就会报错！！ ​
    3.类型转换异常：ClassCastException。 ​ 4.迭代器遍历没有此元素异常：NoSuchElementException。 ​ 5.数学操作异常：ArithmeticException。 ​ 6.数字转换异常：
    NumberFormatException。

    #### Throwable 类常用方法有哪些？

    - `String getMessage()`: 返回异常发生时的简要描述
    - `String toString()`: 返回异常发生时的详细信息
    - `String getLocalizedMessage()`: 返回异常对象的本地化信息。使用 `Throwable`
      的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage()`返回的结果相同
    - `void printStackTrace()`: 在控制台上打印 `Throwable` 对象封装的异常信息

    #### try-catch-finally 如何使用？

    - **`try`块：** 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。
    - **`catch`块：** 用于处理 try 捕获到的异常。
    - **`finally` 块：** 无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。

    **
    注意：不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return
    返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。

    #### finally 中的代码一定会执行吗？

    不一定的！在某些情况下，finally 中的代码不会被执行。

    就比如说 `finally` 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。

    另外，在以下 2 种特殊情况下，`finally` 块的代码也不会被执行：

    1. 程序所在的线程死亡。
    2. 关闭 CPU。

16. ### 序列化和反序列化【⭐⭐】

    如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。

    简单来说：

    - **序列化**： 将数据结构或对象转换成二进制字节流的过程
    - **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

    对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。

    #### Java 序列化中如果有些字段不想进行序列化，怎么办？

    对于不想进行序列化的变量，使用 `transient` 关键字修饰。

    `transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

    关于 `transient` 还有几点注意：

    - `transient` 只能修饰变量，不能修饰类和方法。
    - `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
    - `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。

17. ### 反射【⭐⭐】面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景。

    通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

    反射机制优缺点

    - **优点** ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利
    - **缺点** ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。

18. ### `List`、Set`、` `Map` 的区别。【⭐⭐】

    Set系列集合：添加的元素是无序，不重复，无索引的。

    - HashSet:添加的元素是无序，不重复，无索引的。
        - LinkedHashSet:添加的元素是有序，不重复，无索引的。
    - TreeSet:不重复，无索引，按照大小默认升序排序!!

    List系列集合：添加的元素是有序，可重复，有索引。

    - ArrayList：添加的元素是有序，可重复，有索引。
    - LinkedList：添加的元素是有序，可重复，有索引。

    Map集合的特点： 1.Map集合的特点都是由键决定的。 2.Map集合的键是无序,不重复的，无索引的。 Map集合后面重复的键对应的元素会覆盖前面的整个元素！ 3.Map集合的值无要求。 4.Map集合的键值对都可以为null。

19. ### **`ArrayList` 和 `LinkedList` 的区别。**【⭐⭐⭐⭐】：答清楚每个分别采用什么数据结构，对比相应的优点和缺点。

    ArrayList:：底层基于数组存储数据的，查询快，增删慢！！

    LinkedList：底层是基于双链表的，增删比较快，查询慢！！ LinkedList是支持双链表，定位前后的元素是非常快的，增删首尾的元素也是最快的

20. ### 比较 `HashSet`、`LinkedHashSet` 和 `TreeSet` 三者的异同。【⭐⭐⭐】

    如果希望元素可以重复，又有索引，查询要快用ArrayList集合。（用的最多） 如果希望元素可以重复，又有索引，增删要快要用LinkedList集合。（适合查询元素比较少的情况，经常要首尾操作元素的情况）
    如果希望增删改查都很快，但是元素不重复以及无序无索引，那么用HashSet集合。 如果希望增删改查都很快且有序，但是元素不重复以及无索引，那么用LinkedHashSet集合。

    #### TreeSet

    底层基于TreeMap实现

21. ### HashMap 多线程操作导致死循环问题。【⭐⭐⭐】jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 `HashMap`,因为多线程下使用 `HashMap` 还是会存在其他问题比如数据丢失。并发环境下推荐使用 `ConcurrentHashMap` 。

22. ### HashMap 的长度为什么是 2 的幂次方。【⭐⭐⭐】主要是考虑到了对运算效率的提升。

23. ### **`HashMap`、`HashTable`、以及 `ConcurrentHashMap` 的区别。**【⭐⭐⭐⭐⭐】

    1. **线程是否安全：** `HashMap` 是非线程安全的，`Hashtable` 是线程安全的,因为 `Hashtable` 内部的方法基本都经过`synchronized`
       修饰。（如果你要保证线程安全的话就使用 `ConcurrentHashMap` 吧！）；
    2. **效率：** 因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰，不要在代码中使用它；
    3. **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有
       null 键和 null 值，否则会抛出 `NullPointerException`。
    4. **初始容量大小和每次扩充容量大小的不同 ：** ① 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为
       16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 `HashMap` 会将其扩充为 2 的幂次方大小（`HashMap`
       中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。
    5. **底层数据结构：** JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于
       64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

    `ConcurrentHashMap` 和 `Hashtable` 的区别主要体现在实现线程安全的方式上不同。

    - **底层数据结构：** JDK1.7 的 `ConcurrentHashMap` 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 `HashMap1.8`
      的结构一样，数组+链表/红黑二叉树。`Hashtable` 和 JDK1.8 之前的 `HashMap` 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap
      的主体，链表则是主要为了解决哈希冲突而存在的；
    - **实现线程安全的方式（重要）：** ① **在 JDK1.7 的时候，`ConcurrentHashMap`（分段锁）** 对整个桶数组进行了分割分段(`Segment`)
      ，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 **到了 JDK1.8 的时候已经摒弃了 `Segment` 的概念，而是直接用 `Node`
      数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。（JDK1.6 以后 对 `synchronized` 锁做了很多优化）**
      整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② **`Hashtable`(同一把锁)** :
      使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用
      get，竞争会越来越激烈效率越低。

24. ### Queue 与 Deque 的区别

    `Queue` 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 **先进先出（FIFO）** 规则。

    `Queue` 扩展了 `Collection` 的接口，根据 **因为容量问题而导致操作失败后处理方式的不同** 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。

    | `Queue` 接口 | 抛出异常  | 返回特殊值 |
            | ------------ | --------- | ---------- |
    | 插入队尾     | add(E e)  | offer(E e) |
    | 删除队首     | remove()  | poll()     |
    | 查询队首元素 | element() | peek()     |

    `Deque`实现了Queue接口是双端队列，在队列的两端均可以插入或删除元素。

    `Deque` 扩展了 `Queue` 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：

    | `Deque` 接口 | 抛出异常      | 返回特殊值      |
            | ------------ | ------------- | --------------- |
    | 插入队首     | addFirst(E e) | offerFirst(E e) |
    | 插入队尾     | addLast(E e)  | offerLast(E e)  |
    | 删除队首     | removeFirst() | pollFirst()     |
    | 删除队尾     | removeLast()  | pollLast()      |
    | 查询队首元素 | getFirst()    | peekFirst()     |
    | 查询队尾元素 | getLast()     | peekLast()      |

    事实上，`Deque` 还提供有 `push()` 和 `pop()` 等其他方法，可用于模拟栈。

